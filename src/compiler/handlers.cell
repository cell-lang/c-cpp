implicit prg_data : PrgData, rel_vars_perm_map : [DBSymbol -> [RelVar -> [+Nat -> Nat]]], context : <core>, block : StaticBlock, debug_mode : Bool, skip_integrity_checks : Bool {
  Maybe[Instr*] native_optimized_handler_code(DBSymbol block_name, HandlerId handler_id, NeType msg_type, Instr* body) {
    effects_info = instrs_effects_info(body);

    return nothing if not is_optimizable(effects_info);

    code, table_var_aux_vars_map, memb_var_aux_vars_map = mandatory_only_optimized_handler_code(block_name, handler_id, msg_type, body, effects_info);

    insertion_value_stores = value_stores_with_insertions(block.handlers(handler_id));

    insertion_tables = [t : t <- table_vars_with_insertions(handler_id, ?)];
    update_tables = [t : t <- table_vars_with_updates(handler_id, ?)];
    deletion_tables = [t : t <- table_vars_with_deletions(handler_id, ?)];

    memb_var_status_vars = [sv : _ vs <- table_var_aux_vars_map | _ vs <- memb_var_aux_vars_map, (_, just(sv?)) ?= vs];
    code = (set_bvar(v, false) : v <- isort(memb_var_status_vars)) & code;

    code = code & updates_check_code(block, insertion_tables, update_tables, deletion_tables, table_var_aux_vars_map, effects_info);
    code = code & updates_apply_code(block, insertion_value_stores, table_var_aux_vars_map, memb_var_aux_vars_map, effects_info);

    code = (code | ret_val(true));

    return just(code);
  }


  (Instr*, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])], [MembVar -> (LocVar, Maybe[LocBoolVar])])
  mandatory_only_optimized_handler_code(DBSymbol block_name, HandlerId handler_id, NeType msg_type, Instr* body, EffectsInfo effects_info) {
    tables_types = prg_data.tables(block_name);
    unavailable_vars = temp_table_col_vars_in_use(body);

    table_var_aux_vars_map = [];
    for table_var table_effects_info <- effects_info.tables {
      instr_id, action = only_pair(table_effects_info);
      aux_vars, unavailable_vars = table_aux_vars(tables_types(table_var), unavailable_vars);
      maybe_status_var, unavailable_vars = reserve_maybe_loc_bool_var(not instr_is_always_exec_once(instr_id), unavailable_vars);
      table_var_aux_vars_map = _put_(table_var_aux_vars_map, table_var, (aux_vars, maybe_status_var));
    }

    memb_var_aux_vars_map = [];
    for memb_var instr_ids <- effects_info.memb_vars {
      aux_vars, unavailable_vars = reserve_any_available_loc_var(unavailable_vars);
      maybe_status_var, unavailable_vars = reserve_maybe_loc_bool_var(not memb_var_is_always_set_once(instr_ids), unavailable_vars);
      memb_var_aux_vars_map = _put_(memb_var_aux_vars_map, memb_var, (aux_vars, maybe_status_var));
    }

    rw_body = join((rewrite_handler_code(i, table_var_aux_vars_map, memb_var_aux_vars_map) : i <- body));
    return (rw_body, table_var_aux_vars_map, memb_var_aux_vars_map);


    (LocInt32Var+, [TempTableColVar]) table_aux_vars(Table table_type, [TempTableColVar] unavailable_vars) =
      reserve_any_available_loc_int32_vars(arity(table_type), unavailable_vars);


    (LocInt32Var+, [TempTableColVar]) table_aux_vars(MasterBinTable table_type, [TempTableColVar] unavailable_vars) =
      reserve_any_available_loc_int32_vars(3, unavailable_vars);


    (LocInt32Var+, [TempTableColVar]) table_aux_vars(SlaveTernTable table_type, [TempTableColVar] unavailable_vars) =
      reserve_any_available_loc_int32_vars(2, unavailable_vars);


    ((LocInt32Var, <LocVar, LocIntVar, LocFloatVar>), [TempTableColVar]) table_aux_vars(AnyColumn col_type, [TempTableColVar] init_unavailable_vars) {
      unavailable_vars = init_unavailable_vars;
      key_var = any_available_loc_int32_var(unavailable_vars);
      unavailable_vars = _insert_(unavailable_vars, key_var);
      value_var = match (col_type.repr)
        object  = any_available_loc_var(unavailable_vars),
        int     = any_available_loc_int_var(unavailable_vars),
        float   = any_available_loc_float_var(unavailable_vars);
      unavailable_vars = _insert_(unavailable_vars, value_var);
      return ((key_var, value_var), unavailable_vars);
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Int32Var+ cast_int32_var_seq(TempTableColVar+ vars) = if vars :: Int32Var+ then vars else undefined;


Instr* rewrite_handler_code(Instr instr, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])] table_var_aux_vars_map, [MembVar -> (LocVar, Maybe[LocBoolVar])] memb_var_aux_vars_map) {
  return match (instr)
    // queue_deletes()                = undefined,
    // lookup_or_queue_insert_value() = status, ## IMPLEMENT IMPLEMENT IMPLEMENT
    queue_insert_tuple()            = rewrite_queue_insert_tuple(instr.table_var, instr.tuple, table_var_aux_vars_map),
    queue_insert_master_tuple()     = rewrite_queue_insert_master_tuple(instr.assoc_surr_var, instr.table_var, instr.table, instr.tuple, table_var_aux_vars_map),
    column_insert_deferred()        = rewrite_column_insert_deferred(instr.table_var, instr.column, instr.key_surr, instr.value, instr.forced, table_var_aux_vars_map),
    set_var()                       = if instr.var :: PendingStateVar
                                        then rewrite_set_memb_var(instr.var, instr.value, memb_var_aux_vars_map(corresponding_memb_var(instr.var)))
                                        else (instr),
    branch()                        = if instr.cond :: <neg(is_blank(PendingStateVar))>
                                        then instr.when_false
                                        else rewrite_nested_one_to_many(instr, rewrite_handler_code($, table_var_aux_vars_map, memb_var_aux_vars_map), $),
    _                               = rewrite_nested_one_to_many(instr, rewrite_handler_code($, table_var_aux_vars_map, memb_var_aux_vars_map), $);


  Instr* rewrite_set_memb_var(PendingStateVar var, ObjExpr value_expr, (LocVar, Maybe[LocBoolVar]) aux_vars) {
    aux_var, maybe_status_var = aux_vars;
    set_var_instr = set_var(aux_var, value_expr);
    if maybe_status_var == nothing
      return (set_var_instr);
    status_var = value(maybe_status_var);
    return (
      do_if(is_true(status_var), ret_val(false)), ## TODO: ADD ERROR MESSAGE
      set_bvar(status_var, true),
      set_var_instr
    );
  }


  Instr* rewrite_queue_insert_tuple(TableVar table_var, Int32Var+ tuple, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])] table_var_aux_vars_map) {
    aux_vars, maybe_status_var = table_var_aux_vars_map(table_var);
    assert |aux_vars| == |tuple|;
    aux_vars = cast_int32_var_seq(aux_vars);
    ## MAYBE WE COULD CHECK TO SEE IF THE TABLE ALREADY CONTAINS THE TUPLE WE'RE INSERTING
    code = (set_ivar32(aux_vars(i), v) : v @ i <- tuple);
    if maybe_status_var != nothing {
      status_var = value(maybe_status_var);
      code = (code | set_bvar(status_var, true));
    }
    return code;
  }


  Instr* rewrite_queue_insert_master_tuple(Int32Var assoc_surr_var, TableVar table_var, MasterBinTable table, (Int32Var, Int32Var) tuple, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])] table_var_aux_vars_map) {
    aux_vars, maybe_status_var = table_var_aux_vars_map(table_var);
    aux_vars = cast_int32_var_seq(aux_vars);
    assert |aux_vars| == 3;
    return (
      set_ivar32(assoc_surr_var, get_assoc_surr(table_var, table, tuple)),
      branch(
        are_eq(assoc_surr_var, -1),
        ( set_ivar32(aux_vars(0), tuple(0)),
          set_ivar32(aux_vars(1), tuple(1)),
          set_ivar32(assoc_surr_var, get_first_free_assoc_surr(table_var)),
          ## BAD BAD BAD: THIS IS NOT REALLY NECESSARY, THERE'S ENOUGH INFORMATION ALREADY TO DETERMINE IF THE INSERTION TOOK PLACE
          set_bvar(value(maybe_status_var), true) if maybe_status_var != nothing
        ),
        (set_ivar32(aux_vars(0), -1))
      ),
      set_ivar32(aux_vars(2), assoc_surr_var)
    );
  }


  // column_insert_deferred(table_var: TableVar, column: AnyColumn, key_surr: Int32Var, value: AnyTypeExpr, forced: Bool)
  Instr* rewrite_column_insert_deferred(TableVar table_var, AnyColumn column, Int32Var key_surr, AnyTypeExpr value_expr, Bool forced, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])] table_var_aux_vars_map) {
    aux_vars, maybe_status_var = table_var_aux_vars_map(table_var);
    fail if not aux_vars :: (Int32Var, <LocVar, LocIntVar, LocFloatVar>);
    tmp_key_var, tmp_value_var = aux_vars;
    return (
      set_ivar32(tmp_key_var, key_surr),
      set_any_var(tmp_value_var, obj_expr(value_expr)),
      set_bvar(value(maybe_status_var), true) if maybe_status_var != nothing
    );
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit prg_data : PrgData, rel_vars_perm_map : [DBSymbol -> [RelVar -> [+Nat -> Nat]]], context : <core>, debug_mode : Bool, skip_integrity_checks : Bool {
  Instr* updates_check_code(StaticBlock block, [TableVar] insertion_tables, [TableVar] update_tables, [TableVar] deletion_tables, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])] table_var_aux_vars_map, EffectsInfo effects_info) {
    mutated_tables = insertion_tables & deletion_tables;
    mutated_tables = sort_by_key(mutated_tables, arity(block.tables($)));

    insert_checked_foreign_keys = [k : k s <- block.foreign_keys, s.insertion_checked, insertion_tables(k.origin)];
    insert_checked_foreign_keys = sort_by_key(insert_checked_foreign_keys, order);

    update_checked_foreign_keys = [k : k _ <- block.foreign_keys, update_tables(k.origin)];
    update_checked_foreign_keys = sort_by_key(update_checked_foreign_keys, order);

    delete_checked_foreign_keys = [k : k s <- block.foreign_keys, s.deletion_checked, insertion_tables(k.origin)];
    delete_checked_foreign_keys = sort_by_key(delete_checked_foreign_keys, order);

    tables = block.tables;
    cols_subset_map = block.cols_subset_map;

    key_check_exprs = [];
    for v vs <- table_var_aux_vars_map {
      if not insertion_is_forced(v, effects_info) {
        aux_vars, maybe_status_var = vs;

        table = tables(v);
        table_arity = arity(table);

        if table_arity == 2 {
          if not is_symmetric(table) {
            keys = keys(table);
            relvar = original_rel_var(v);

            for idx <- [only(k) : k <- keys] {
              col = phys_col(relvar, idx);
              col_equivs = [];
              for c <- cols_subset_map(col, ?) {
                if cols_subset_map(c, col) {
                  equiv_table_var = table_var(c.relvar);
                  equiv_table = tables(equiv_table_var);
                  if arity(equiv_table) == 1
                    col_equivs = _insert_(col_equivs, equiv_table_var);
                }
              }

              tmp_key_var = cast_int32_var(aux_vars(idx));

              if col_equivs != [] {
                col_equiv = any(col_equivs);
                key_check_expr = table_contains(col_equiv, tables(col_equiv), (just(tmp_key_var)));
              }
              else
                key_check_expr = table_contains(v, table, (if i == idx then just(tmp_key_var) else nothing : i < 2));

              if maybe_status_var != nothing {
                status_var = value(maybe_status_var);
                key_check_expr = and_then(status_var, key_check_expr);
              }

              key_check_exprs = _insert_(key_check_exprs, key_check_expr);
            }
          }
          else {
            ## CAN SYMMETRIC TABLE HAVE KEYS?
            fail; ## IMPLEMENT IMPLEMENT IMPLEMENT
          }
        }
        else if table_arity == 3 {
          fail; ## IMPLEMENT IMPLEMENT IMPLEMENT
        }
      }
    }

    check_code = ();

    for e <- key_check_exprs
      check_code = (check_code | do_if(e, ret_val(false)));

    for k <- insert_checked_foreign_keys & update_checked_foreign_keys {
      check_expr = foreign_key_forward_check_expr(k, block, table_var_aux_vars_map);
      check_code = (check_code | do_if(check_expr, ret_val(false)));
    }

    for k <- delete_checked_foreign_keys {
      check_expr = foreign_key_backward_check_expr(k, block, table_var_aux_vars_map);
      check_code = (check_code | do_if(check_expr, ret_val(false)));
    }

    check_code = () if skip_integrity_checks;

    return check_code;


    BoolExpr foreign_key_forward_check_expr(BlockForeignKey key, StaticBlock block, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])] table_var_aux_vars_map) {
      origin = key.origin;
      target = key.target;

      target_type = block.tables(target);
      origin_aux_vars, maybe_origin_status_var = table_var_aux_vars_map(origin);

      args_set = match (key.type)
        unary_unary             = ((just(cast_int32_var(origin_aux_vars(0))))),
        unary_binary(i?)        = ((if j == i then just(cast_int32_var(origin_aux_vars(0))) else nothing : j < 2)),
        unary_ternary(i?)       = ((if j == i then just(cast_int32_var(origin_aux_vars(0))) else nothing : j < 3)),
        binary_unary(i?)        |
        ternary_unary(i?)       = ((just(cast_int32_var(origin_aux_vars(i))))),
        binary_ternary          = ((just(cast_int32_var(origin_aux_vars(0))), just(cast_int32_var(origin_aux_vars(1))), nothing)),
        ternary_binary          = ((just(cast_int32_var(origin_aux_vars(0))), just(cast_int32_var(origin_aux_vars(1))))),
        unary_sym_binary        = ((just(cast_int32_var(origin_aux_vars(0))), nothing)),
        unary_sym_ternary_12    = ((just(cast_int32_var(origin_aux_vars(0))), nothing, nothing)),
        unary_sym_ternary_3     = ((nothing, nothing, just(cast_int32_var(origin_aux_vars(0))))),
        sym_binary_unary        |
        sym_ternary_unary_12    = ((just(cast_int32_var(origin_aux_vars(j)))) : j < 2),
        sym_ternary_unary_3     = ((just(cast_int32_var(origin_aux_vars(2))))),
        ## ASSUMING THAT THE TWO SYMMETRIC SURROGATES HAVE BEEN ORDERED. THIS IS CURRENTLY NOT TRUE
        ## IMPLEMENT IT AND ADD A DEBUG MODE CHECK TO VERIFY IT
        sym_binary_sym_ternary  = ((just(cast_int32_var(origin_aux_vars(0))), just(cast_int32_var(origin_aux_vars(1))), nothing)),
        sym_ternary_sym_binary  = ((just(cast_int32_var(origin_aux_vars(0))), just(cast_int32_var(origin_aux_vars(1)))));

      check_expr = neg(and((table_contains(target, target_type, as) : as <- args_set)));

      if table_var_aux_vars_map(target, _) {
        target_aux_vars, maybe_target_status_var = table_var_aux_vars_map(target);

        neg_extra_check = match (key.type)
          unary_unary             = are_eq(cast_int32_var(origin_aux_vars(0)), cast_int32_var(target_aux_vars(0))),
          unary_binary(i?)        |
          unary_ternary(i?)       = are_eq(cast_int32_var(origin_aux_vars(0)), cast_int32_var(target_aux_vars(i))),
          binary_unary(i?)        |
          ternary_unary(i?)       = are_eq(cast_int32_var(origin_aux_vars(i)), cast_int32_var(target_aux_vars(0))),
          binary_ternary          |
          ternary_binary          = and((are_eq(cast_int32_var(origin_aux_vars(j)), cast_int32_var(target_aux_vars(j))) : j < 2)),
          unary_sym_binary        |
          unary_sym_ternary_12    = or((are_eq(cast_int32_var(origin_aux_vars(0)), cast_int32_var(target_aux_vars(j))) : j < 2)),
          unary_sym_ternary_3     = are_eq(cast_int32_var(origin_aux_vars(0)), cast_int32_var(target_aux_vars(2))),
          sym_binary_unary        |
          sym_ternary_unary_12    = or((are_eq(cast_int32_var(origin_aux_vars(j)), cast_int32_var(target_aux_vars(0))) : j < 2)),
          sym_ternary_unary_3     = are_eq(cast_int32_var(origin_aux_vars(2)), cast_int32_var(target_aux_vars(0))),
          sym_binary_sym_ternary  |
          ## ASSUMING THAT THE TWO SYMMETRIC SURROGATES HAVE BEEN ORDERED. THIS IS CURRENTLY NOT TRUE
          ## IMPLEMENT IT AND ADD A DEBUG MODE CHECK TO VERIFY IT
          sym_ternary_sym_binary  = and((are_eq(cast_int32_var(origin_aux_vars(j)), cast_int32_var(target_aux_vars(j))) : j < 2));
        extra_check = neg(neg_extra_check);

        if maybe_target_status_var != nothing {
          target_status_var = value(maybe_target_status_var);
          extra_check = or_else(neg(target_status_var), extra_check);
        }

        check_expr = and(check_expr, extra_check);
      }

      if maybe_origin_status_var != nothing {
        origin_status_var = value(maybe_origin_status_var);
        check_expr = and_then(origin_status_var, check_expr);
      }

      return check_expr;
    }


    BoolExpr foreign_key_backward_check_expr(BlockForeignKey key, StaticBlock block, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])] table_var_aux_vars_map) {
      fail; ## IMPLEMENT IMPLEMENT IMPLEMENT
    }


    Nat order(BlockForeignKey key) =
      match (key.type)
        unary_unary             = 0,
        unary_binary(i?)        = i,
        unary_ternary(i?)       = i,

        binary_unary(i?)        = i,
        binary_ternary          = 0,

        ternary_unary(i?)       = i,
        ternary_binary          = 0,

        unary_sym_binary        = 0,
        sym_binary_unary        = 0,

        unary_sym_ternary_12    = 0,
        unary_sym_ternary_3     = 2,

        sym_ternary_unary_12    = 0,
        sym_ternary_unary_3     = 2,

        sym_binary_sym_ternary  = 0,
        sym_ternary_sym_binary  = 0;
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  Instr* updates_apply_code(StaticBlock block, [ValueStoreId] insertion_value_stores, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])] table_var_aux_vars_map, [MembVar -> (LocVar, Maybe[LocBoolVar])] memb_var_aux_vars_map, EffectsInfo effects_info) {
    ord_value_stores = isort(insertion_value_stores);
    ord_table_vars = sort_set(keys(table_var_aux_vars_map), arity(block.tables($a)) < arity(block.tables($b)));
    ord_memb_vars = isort(keys(memb_var_aux_vars_map));

    code = ();
    for vs <- ord_value_stores {
      instr = value_store_apply(vs, block.value_stores(vs));
      code = (code | instr);
    }
    for v <- ord_table_vars {
      aux_vars, maybe_status_var = table_var_aux_vars_map(v);
      instr_id, action = only_pair(effects_info.tables(v));
      instrs = immediate_insert_instrs(block, v, block.tables(v), aux_vars, action);
      if maybe_status_var != nothing {
        status_var = value(maybe_status_var);
        instrs = (do_if(status_var, instrs));
      }
      code = code & instrs;
    }
    for v <- ord_memb_vars {
      aux_var, maybe_status_var = memb_var_aux_vars_map(v);
      instr = set_var(v, aux_var);
      if maybe_status_var != nothing {
        status_var = value(maybe_status_var);
        instr = do_if(status_var, (instr));
      }
      code = (code | instr);
    }
    return code;


    Instr* immediate_insert_instrs(StaticBlock block, TableVar table_var, Table table, TempTableColVar+ aux_vars, TableAction action) {
      assert action == :insertion;

      main_resize_instr = immediate_insert_tuple(table_var, table, cast_int32_var_seq(aux_vars));

      if arity(table) == 1 {
        masters_raw_columns = prg_data.masters_raw_columns(block.name);
        if masters_raw_columns(table_var, _) {
          raw_cols = isort([v : v <- masters_raw_columns(table_var, ?)]);
          size_var = new_unique_int32_var(:unused);
          new_size_var = new_unique_int32_var(:unused);
          size_expr = get_count(table_var, table, (nothing));
          resize_instrs = (resize_mandatory_column(v, cast_mandatory_column(block.tables(v)), size_var, new_size_var) : v <- raw_cols);
          return (
            set_ivar32(size_var, size_expr),
            main_resize_instr,
            set_ivar32(new_size_var, size_expr),
            do_if_not(are_eq(size_var, new_size_var), resize_instrs)
          );
        }
      }

      return (main_resize_instr);
    }


    Instr* immediate_insert_instrs(StaticBlock block, TableVar table_var, <MasterBinTable, SlaveTernTable> table, TempTableColVar+ aux_vars, TableAction action) {
      assert action == :insertion;
      return (immediate_insert_tuple(table_var, table, cast_int32_var_seq(aux_vars)));
    }


    Instr* immediate_insert_instrs(StaticBlock block, TableVar table_var, AnyColumn column, TempTableColVar+ aux_vars, TableAction action) {
      assert action == :insertion or action == :update;
      assert |aux_vars| == 2;
      key_var = cast_int32_var(aux_vars(0));
      value_var = aux_vars(1);
      return (column_insert_immediate(table_var, column, key_var, value_var, action == :update));
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Bool is_optimizable(EffectsInfo effects_info) {
  for v is <- effects_info.tables {
    return false if |is| != 1;
    i, a = only_pair(is);
    return false if a != :insertion and a != :update;
    status = instr_status(i);
    return false if status.multiple;
  }
  return true;
}


## THIS IS NOT A GOOD WAY TO DO IT. IT SHOULD BE DECIDED WHILE FIGURING OUT THE EFFECTS, BECAUSE BY DOING SO
## WE COULD FOR EXAMPLE DEAL WITH THE CASE OF A MEMBER VARIABLES THAT IS SET IN BOTH BRANCHES OF AN IF STATEMENT

Bool instr_is_always_exec_once(InstrId instr_id) {
  status = instr_status(instr_id);
  return not status.optional and not status.multiple;
}

Bool memb_var_is_always_set_once([+InstrId] instr_ids) = |instr_ids| == 1 and instr_is_always_exec_once(only(instr_ids));


Bool insertion_is_forced(TableVar var, EffectsInfo effects_info) {
  _, action = only_pair(effects_info.tables(var));
  return action == :update;
}
