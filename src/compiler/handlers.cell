implicit prg_data : PrgData, rel_vars_perm_map : [DBSymbol -> [RelVar -> [+Nat -> Nat]]], context : <core>, block : StaticBlock, debug_mode : Bool, skip_integrity_checks : Bool {
  Maybe[Instr*] native_optimized_handler_code(HandlerId handler_id, NeType msg_type, Instr* body) {
    effects_info = instrs_effects_info(body);

    return nothing if not is_optimizable(effects_info);

    code, table_var_aux_vars_map, memb_var_aux_vars_map = mandatory_only_optimized_handler_code(handler_id, msg_type, body, effects_info);

    insertion_value_stores = value_stores_with_insertions(block.handlers(handler_id));

    insertion_tables = [t : t <- table_vars_with_insertions(handler_id, ?)];
    update_tables = [t : t <- table_vars_with_updates(handler_id, ?)];
    deletion_tables = [t : t <- table_vars_with_deletions(handler_id, ?)];

    memb_var_status_vars = [sv : _ vs <- table_var_aux_vars_map | _ vs <- memb_var_aux_vars_map, (_, just(sv?)) ?= vs];
    code = (set_bvar(v, false) : v <- isort(memb_var_status_vars)) & code;

    code = code & updates_check_code(block, insertion_tables, update_tables, deletion_tables, table_var_aux_vars_map, effects_info);
    code = code & updates_apply_code(block, insertion_value_stores, table_var_aux_vars_map, memb_var_aux_vars_map, effects_info);
    code = code & updates_reset_code(block, insertion_value_stores);

    code = (code | ret_val(true));

    return just(code);
  }


  (Instr*, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])], [MembVar -> (LocVar, Maybe[LocBoolVar])])
  mandatory_only_optimized_handler_code(HandlerId handler_id, NeType msg_type, Instr* body, EffectsInfo effects_info) {
    tables_types = prg_data.tables(block.name);
    unavailable_vars = temp_table_col_vars_in_use(body);

    table_var_aux_vars_map = [];
    for table_var table_effects_info <- effects_info.tables {
      instr_id, action = only_pair(table_effects_info);
      instr = get_instr_by_id(instr_id, body);
      aux_vars, unavailable_vars = table_aux_vars(tables_types(table_var), instr, unavailable_vars);
      maybe_status_var, unavailable_vars = reserve_maybe_loc_bool_var(not instr_is_always_exec_once(instr_id), unavailable_vars);
      table_var_aux_vars_map = _put_(table_var_aux_vars_map, table_var, (aux_vars, maybe_status_var));
    }

    memb_var_aux_vars_map = [];
    for memb_var instr_ids <- effects_info.memb_vars {
      aux_vars, unavailable_vars = reserve_any_available_loc_var(unavailable_vars);
      maybe_status_var, unavailable_vars = reserve_maybe_loc_bool_var(not memb_var_is_always_set_once(instr_ids), unavailable_vars);
      memb_var_aux_vars_map = _put_(memb_var_aux_vars_map, memb_var, (aux_vars, maybe_status_var));
    }

    rw_body = join((rewrite_handler_code(i, table_var_aux_vars_map, memb_var_aux_vars_map) : i <- body));
    return (rw_body, table_var_aux_vars_map, memb_var_aux_vars_map);


    (LocInt32Var+, [TempTableColVar]) table_aux_vars(Table table_type, Instr instr, [TempTableColVar] unavailable_vars) =
      reserve_any_available_loc_int32_vars(arity(table_type), unavailable_vars);


    (LocInt32Var+, [TempTableColVar]) table_aux_vars(MasterBinTable table_type, Instr instr, [TempTableColVar] unavailable_vars) =
      reserve_any_available_loc_int32_vars(3, unavailable_vars);


    (LocInt32Var+, [TempTableColVar]) table_aux_vars(SlaveTernTable table_type, Instr instr, [TempTableColVar] unavailable_vars) =
      ## BUG BUG BUG: IT MAY NEED 3 VARIABLES. TRY TO TRIGGER THIS BUG BEFORE FIXING IT
      reserve_any_available_loc_int32_vars(2, unavailable_vars);


    ((LocInt32Var, <LocVar, LocIntVar, LocFloatVar>), [TempTableColVar]) table_aux_vars(<Column, MandatoryColumn> col_type, Instr instr, [TempTableColVar] init_unavailable_vars) {
      unavailable_vars = init_unavailable_vars;
      key_var = any_available_loc_int32_var(unavailable_vars);
      unavailable_vars = _insert_(unavailable_vars, key_var);
      value_var = match (col_type.repr)
        object  = any_available_loc_var(unavailable_vars),
        int     = any_available_loc_int_var(unavailable_vars),
        float   = any_available_loc_float_var(unavailable_vars);
      unavailable_vars = _insert_(unavailable_vars, value_var);
      return ((key_var, value_var), unavailable_vars);
    }


    (<(LocInt32Var, <LocVar, LocIntVar, LocFloatVar>), (LocInt32Var, LocInt32Var, <LocVar, LocIntVar, LocFloatVar>)>, [TempTableColVar])
    table_aux_vars(SlaveColumn col_type, Instr generic_instr, [TempTableColVar] init_unavailable_vars) {
      // column_insert_deferred(table_var: TableVar, column: AnyColumn, key_surr: <Int32Var, (Int32Var, Int32Var)>, value: AnyTypeExpr, forced: Bool),
      instr = match (generic_instr) column_insert_deferred() = generic_instr;
      unavailable_vars = init_unavailable_vars;

      value_var, unavailable_vars = match (col_type.repr)
        object  = reserve_any_available_loc_var(unavailable_vars),
        int     = reserve_any_available_loc_int_var(unavailable_vars),
        float   = reserve_any_available_loc_float_var(unavailable_vars);

      if instr.args_surrs == nothing {
        key_var, unavailable_vars = reserve_any_available_loc_int32_var(unavailable_vars);
        vars = (key_var, value_var);
      }
      else {
        arg1_var, unavailable_vars = reserve_any_available_loc_int32_var(unavailable_vars);
        arg2_var, unavailable_vars = reserve_any_available_loc_int32_var(unavailable_vars);
        vars = (arg1_var, arg2_var, value_var);
      }

      return (vars, unavailable_vars);
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Instr* rewrite_handler_code(Instr instr, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])] table_var_aux_vars_map, [MembVar -> (LocVar, Maybe[LocBoolVar])] memb_var_aux_vars_map) {
  return match (instr)
    // queue_deletes()                = undefined,
    // lookup_or_queue_insert_value() = status, ## IMPLEMENT IMPLEMENT IMPLEMENT
    queue_insert_tuple()            = rewrite_queue_insert_tuple(instr.table_var, instr.tuple, instr.forced, table_var_aux_vars_map),
    queue_insert_master_tuple()     = rewrite_queue_insert_master_tuple(instr.assoc_surr_var, instr.table_var, instr.table, instr.tuple, table_var_aux_vars_map),
    column_insert_deferred()        = rewrite_column_insert_deferred(instr.table_var, instr.column, instr.key_surr, instr.args_surrs, instr.value, instr.forced, table_var_aux_vars_map),
    set_var()                       = if instr.var :: PendingStateVar
                                        then rewrite_set_memb_var(instr.var, instr.value, memb_var_aux_vars_map(corresponding_memb_var(instr.var)))
                                        else (instr),
    branch()                        = if instr.cond :: <neg(is_blank(PendingStateVar))>
                                        then instr.when_false
                                        else rewrite_nested_one_to_many(instr, rewrite_handler_code($, table_var_aux_vars_map, memb_var_aux_vars_map), $),
    _                               = rewrite_nested_one_to_many(instr, rewrite_handler_code($, table_var_aux_vars_map, memb_var_aux_vars_map), $);


  Instr* rewrite_set_memb_var(PendingStateVar var, ObjExpr value_expr, (LocVar, Maybe[LocBoolVar]) aux_vars) {
    aux_var, maybe_status_var = aux_vars;
    set_var_instr = set_var(aux_var, value_expr);
    if maybe_status_var == nothing
      return (set_var_instr);
    status_var = value(maybe_status_var);
    return (
      do_if(is_true(status_var), ret_val(false)), ## TODO: ADD ERROR MESSAGE
      set_bvar(status_var, true),
      set_var_instr
    );
  }


  Instr* rewrite_queue_insert_tuple(TableVar table_var, Int32Var+ tuple, Bool forced, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])] table_var_aux_vars_map) {
    aux_vars, maybe_status_var = table_var_aux_vars_map(table_var);
    assert |aux_vars| == |tuple|;
    aux_vars = cast_int32_var_seq(aux_vars);
    code = (queue_insert_tuple_rewrite_descr(table_var, aux_vars, maybe_status_var, forced));
    ## MAYBE WE COULD CHECK TO SEE IF THE TABLE ALREADY CONTAINS THE TUPLE WE'RE INSERTING
    code = code & (set_ivar32(aux_vars(i), v) : v @ i <- tuple);
    if maybe_status_var != nothing {
      status_var = value(maybe_status_var);
      code = (code | set_bvar(status_var, true));
    }
    return code;
  }


  Instr* rewrite_queue_insert_master_tuple(Int32Var assoc_surr_var, TableVar table_var, MasterBinTable table, (Int32Var, Int32Var) tuple, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])] table_var_aux_vars_map) {
    aux_vars, maybe_status_var = table_var_aux_vars_map(table_var);
    aux_vars = cast_int32_var_seq(aux_vars);
    assert |aux_vars| == 3;
    return (
      set_ivar32(assoc_surr_var, get_assoc_surr(table_var, table, tuple)),
      do_if(
        are_eq(assoc_surr_var, -1),
        ( set_ivar32(assoc_surr_var, get_first_free_assoc_surr(table_var)),
          set_bvar(value(maybe_status_var), true) if maybe_status_var != nothing
        )
      ),
      queue_insert_master_tuple_rewrite_descr(table_var, aux_vars, maybe_status_var),
      set_ivar32(aux_vars(0), tuple(0)),
      set_ivar32(aux_vars(1), tuple(1)),
      set_ivar32(aux_vars(2), assoc_surr_var)
    );
  }


  Instr* rewrite_column_insert_deferred(TableVar table_var, AnyColumn column, Int32Var key_surr, Maybe[(Int32Var, Int32Var)] args_surrs, AnyTypeExpr value_expr, Bool forced, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])] table_var_aux_vars_map) {
    if args_surrs == nothing {
      aux_vars, maybe_status_var = table_var_aux_vars_map(table_var);
      fail if not aux_vars :: (Int32Var, <LocVar, LocIntVar, LocFloatVar>);
      tmp_key_var, tmp_value_var = aux_vars;
      return (
        column_insert_deferred_rewrite_descr(table_var, aux_vars, maybe_status_var, forced),
        set_ivar32(tmp_key_var, key_surr),
        set_any_var(tmp_value_var, obj_expr(value_expr)),
        set_bvar(value(maybe_status_var), true) if maybe_status_var != nothing
      );
    }
    else {
      fail if not column :: SlaveColumn;
      aux_vars, maybe_status_var = table_var_aux_vars_map(table_var);
      fail if not aux_vars :: (Int32Var, Int32Var, <LocVar, LocIntVar, LocFloatVar>);
      tmp_arg1_var, tmp_arg2_var, tmp_value_var = aux_vars;
      arg1_surr, arg2_surr = value(args_surrs);
      return (
        column_insert_deferred_rewrite_descr(table_var, aux_vars, maybe_status_var, forced),
        set_ivar32(tmp_arg1_var, arg1_surr),
        set_ivar32(tmp_arg2_var, arg2_surr),
        set_any_var(tmp_value_var, obj_expr(value_expr)),
        set_bvar(value(maybe_status_var), true) if maybe_status_var != nothing
      );
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit prg_data : PrgData, rel_vars_perm_map : [DBSymbol -> [RelVar -> [+Nat -> Nat]]], context : <core>, debug_mode : Bool, skip_integrity_checks : Bool {
  Instr* updates_check_code(StaticBlock block, [TableVar] insertion_tables, [TableVar] update_tables, [TableVar] deletion_tables, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])] table_var_aux_vars_map, EffectsInfo effects_info) {
    // mutated_tables = insertion_tables & update_tables & deletion_tables;
    // mutated_tables = sort_by_key(mutated_tables, arity(block.tables($)));

    insert_checked_foreign_keys = [k : k s <- block.foreign_keys, s.insertion_checked, insertion_tables(k.origin)];
    insert_checked_foreign_keys = sort_by_key(insert_checked_foreign_keys, order);

    update_checked_foreign_keys = [k : k _ <- block.foreign_keys, update_tables(k.origin)];
    update_checked_foreign_keys = sort_by_key(update_checked_foreign_keys, order);

    delete_checked_foreign_keys = [k : k s <- block.foreign_keys, s.deletion_checked, deletion_tables(k.target)];
    delete_checked_foreign_keys = sort_by_key(delete_checked_foreign_keys, order);

    tables = block.tables;
    cols_subset_map = block.cols_subset_map;

    key_check_exprs = [];
    for v vs <- table_var_aux_vars_map {
      if not insertion_is_forced(v, effects_info) {
        aux_vars, maybe_status_var = vs;

        table = tables(v);
        table_arity = arity(table);
        keys = keys(table);
        relvar = original_rel_var(v);

        for key <- keys {
          // Remapping the key for slave columns and tables
          low_level_key = low_level_key(key, table);

          // Default expression
          key_check_expr = table_contains(v, table, (if low_level_key(i) then just(cast_int32_var(aux_vars(i))) else nothing : i < table_arity));

          // Optimization for single-column keys where the column can be replaced with an equivalent column of a unary relation
          ## TODO: AN EQUIVALENT OPTIMIZATION COULD BE DONE FOR MULTI-COLUMN KEYS
          if |key| == 1 {
            idx = only(key);
            col = phys_col(relvar, idx);
            col_equivs = [];
            for c <- cols_subset_map(col, ?) {
              if cols_subset_map(c, col) {
                equiv_table_var = table_var(c.relvar);
                equiv_table = tables(equiv_table_var);
                if arity(equiv_table) == 1
                  col_equivs = _insert_(col_equivs, equiv_table_var);
              }
            }

            if col_equivs != [] {
              col_equiv = any(col_equivs);
              low_level_idx = only(low_level_key);
              tmp_key_var = cast_int32_var(aux_vars(low_level_idx));
              key_check_expr = table_contains(col_equiv, tables(col_equiv), (just(tmp_key_var)));
            }
          }

          if maybe_status_var != nothing {
            status_var = value(maybe_status_var);
            key_check_expr = and_then(status_var, key_check_expr);
          }

          key_check_exprs = _insert_(key_check_exprs, key_check_expr);
        }
      }
    }

    check_code = ();

    if key_check_exprs != () {
      check_code = (check_code | comment("Checking keys"));
      for e <- key_check_exprs
        check_code = (check_code | do_if(e, ret_val(false)));
    }

    if insert_checked_foreign_keys != () or update_checked_foreign_keys != () {
      check_code = (check_code | comment("Forward checking of foreign keys"));
      for k <- insert_checked_foreign_keys & update_checked_foreign_keys {
        check_expr = foreign_key_forward_check_expr(k, block, table_var_aux_vars_map);
        check_code = (check_code | do_if(check_expr, ret_val(false)));
      }
    }

    if delete_checked_foreign_keys != () {
      check_code = (check_code | comment("Backward checking of foreign keys"));
      for k <- delete_checked_foreign_keys {
        check_expr = foreign_key_backward_check_expr(k, block, table_var_aux_vars_map);
        check_code = (check_code | do_if(check_expr, ret_val(false)));
      }
    }

    check_code = () if skip_integrity_checks;

    return check_code;


    BoolExpr foreign_key_forward_check_expr(BlockForeignKey key, StaticBlock block, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])] table_var_aux_vars_map) {
      origin = key.origin;
      target = key.target;

      origin_type = block.tables(origin);
      target_type = block.tables(target);
      origin_aux_vars, maybe_origin_status_var = table_var_aux_vars_map(origin);

      check_expr = base_check_expr(key.type, origin_type, origin_aux_vars, target, target_type);

      if table_var_aux_vars_map(target, _) {
        target_aux_vars, maybe_target_status_var = table_var_aux_vars_map(target);

        extra_check = extra_check_expr(key.type, origin_type, origin_aux_vars, target_aux_vars, maybe_target_status_var, target, target_type);

        if maybe_target_status_var != nothing {
          target_status_var = value(maybe_target_status_var);
          extra_check = or_else(neg(target_status_var), extra_check);
        }

        check_expr = and(check_expr, extra_check);
      }

      if maybe_origin_status_var != nothing {
        origin_status_var = value(maybe_origin_status_var);
        check_expr = and_then(origin_status_var, check_expr);
      }

      return check_expr;
    }


    BoolExpr std_base_check_expr(ForeignKeyType key_type, TempTableColVar+ origin_aux_vars, TableVar target, AnyTable target_type, AnyTable origin_type) {
      assert not origin_type :: <SlaveTernTable, SlaveColumn>;

      args_set = match (key_type)
        unary_unary             = ((just(cast_int32_var(origin_aux_vars(0))))),
        unary_binary(i?)        = ((if j == i then just(cast_int32_var(origin_aux_vars(0))) else nothing : j < 2)),
        unary_ternary(i?)       = ((if j == i then just(cast_int32_var(origin_aux_vars(0))) else nothing : j < 3)),
        binary_unary(i?)        |
        ternary_unary(i?)       = ((just(cast_int32_var(origin_aux_vars(i))))),
        binary_ternary          = ((just(cast_int32_var(origin_aux_vars(0))), just(cast_int32_var(origin_aux_vars(1))), nothing)),
        ternary_binary          = ((just(cast_int32_var(origin_aux_vars(0))), just(cast_int32_var(origin_aux_vars(1))))),
        unary_sym_binary        = ((just(cast_int32_var(origin_aux_vars(0))), nothing)),
        unary_sym_ternary_12    = ((just(cast_int32_var(origin_aux_vars(0))), nothing, nothing)),
        unary_sym_ternary_3     = ((nothing, nothing, just(cast_int32_var(origin_aux_vars(0))))),
        sym_binary_unary        |
        sym_ternary_unary_12    = ((just(cast_int32_var(origin_aux_vars(j)))) : j < 2),
        sym_ternary_unary_3     = ((just(cast_int32_var(origin_aux_vars(2))))),
        ## ASSUMING THAT THE TWO SYMMETRIC SURROGATES HAVE BEEN ORDERED. THIS IS CURRENTLY NOT TRUE
        ## IMPLEMENT IT AND ADD A DEBUG MODE CHECK TO VERIFY IT
        sym_binary_sym_ternary  = ((just(cast_int32_var(origin_aux_vars(0))), just(cast_int32_var(origin_aux_vars(1))), nothing)),
        sym_ternary_sym_binary  = ((just(cast_int32_var(origin_aux_vars(0))), just(cast_int32_var(origin_aux_vars(1)))));

      return neg(and((table_contains(target, target_type, as) : as <- args_set)));
    }


    BoolExpr std_extra_check_expr(ForeignKeyType key_type, TempTableColVar+ origin_aux_vars, TempTableColVar+ target_aux_vars, TableVar target, AnyTable target_type, AnyTable origin_type) {
      neg_extra_check = match (key_type)
        unary_unary             = are_eq(cast_int32_var(origin_aux_vars(0)), cast_int32_var(target_aux_vars(0))),
        unary_binary(i?)        |
        unary_ternary(i?)       = are_eq(cast_int32_var(origin_aux_vars(0)), cast_int32_var(target_aux_vars(i))),
        binary_unary(i?)        |
        ternary_unary(i?)       = are_eq(cast_int32_var(origin_aux_vars(i)), cast_int32_var(target_aux_vars(0))),
        binary_ternary          |
        ternary_binary          = and((are_eq(cast_int32_var(origin_aux_vars(j)), cast_int32_var(target_aux_vars(j))) : j < 2)),
        unary_sym_binary        |
        unary_sym_ternary_12    = or((are_eq(cast_int32_var(origin_aux_vars(0)), cast_int32_var(target_aux_vars(j))) : j < 2)),
        unary_sym_ternary_3     = are_eq(cast_int32_var(origin_aux_vars(0)), cast_int32_var(target_aux_vars(2))),
        sym_binary_unary        |
        sym_ternary_unary_12    = or((are_eq(cast_int32_var(origin_aux_vars(j)), cast_int32_var(target_aux_vars(0))) : j < 2)),
        sym_ternary_unary_3     = are_eq(cast_int32_var(origin_aux_vars(2)), cast_int32_var(target_aux_vars(0))),
        sym_binary_sym_ternary  |
        ## ASSUMING THAT THE TWO SYMMETRIC SURROGATES HAVE BEEN ORDERED. THIS IS CURRENTLY NOT TRUE
        ## IMPLEMENT IT AND ADD A DEBUG MODE CHECK TO VERIFY IT
        sym_ternary_sym_binary  = and((are_eq(cast_int32_var(origin_aux_vars(j)), cast_int32_var(target_aux_vars(j))) : j < 2));
      return neg(neg_extra_check);
    }


    BoolExpr slave_ternary_to_binary_base_check_expr(<SlaveTernTable, SlaveColumn> origin_type, TempTableColVar+ origin_aux_vars, TableVar target, AnyTable target_type) {
      assert |origin_aux_vars| == 2 or |origin_aux_vars| == 3;
      neg_expr = if |origin_aux_vars| == 3
        then table_contains(target, target_type, (just(cast_int32_var(origin_aux_vars(i))) : i <- (0, 1)))
        else master_bin_table_contains_assoc_surr(target, cast_master_bin_table(target_type), cast_int32_var(origin_aux_vars(0)));
      return neg(neg_expr);
    }


    BoolExpr slave_ternary_to_unary_base_check_expr(SlaveTernTable origin_type, TempTableColVar+ origin_aux_vars, TableVar target, AnyTable target_type) {
      assert |origin_aux_vars| == 2 or |origin_aux_vars| == 3;
      return neg(table_contains(target, target_type, (just(cast_int32_var(last(origin_aux_vars))))));
    }


    BoolExpr base_check_expr(ForeignKeyType key_type, AnyTable origin_type, TempTableColVar+ origin_aux_vars, TableVar target, AnyTable target_type) =
      unary_unary                               |
      unary_binary()                            |
      binary_unary()                            |
      unary_sym_binary                          |
      sym_binary_unary,     _                   = std_base_check_expr(key_type, origin_aux_vars, target, target_type, origin_type),

      binary_ternary,       _                   = undefined, ## IMPLEMENT IMPLEMENT IMPLEMENT

      ternary_binary,       table()             = std_base_check_expr(key_type, origin_aux_vars, target, target_type, origin_type),
      ternary_binary,       slave_tern_table()  |
                            slave_column()      = slave_ternary_to_binary_base_check_expr(origin_type, origin_aux_vars, target, target_type),

      unary_ternary(i?),    _                   = undefined, ## IMPLEMENT IMPLEMENT IMPLEMENT

      ternary_unary(i?),    table()             = std_base_check_expr(key_type, origin_aux_vars, target, target_type, origin_type),
      ternary_unary(2),     slave_tern_table()  = slave_ternary_to_unary_base_check_expr(origin_type, origin_aux_vars, target, target_type),

      _,                    _                   = undefined; ## IMPLEMENT IMPLEMENT IMPLEMENT


      // ## ASSUMING THAT THE TWO SYMMETRIC SURROGATES HAVE BEEN ORDERED. THIS IS CURRENTLY NOT TRUE
      // ## IMPLEMENT IT AND ADD A DEBUG MODE CHECK TO VERIFY IT
      // sym_binary_sym_ternary  = ((just(cast_int32_var(origin_aux_vars(0))), just(cast_int32_var(origin_aux_vars(1))), nothing)),
      // sym_ternary_sym_binary  = ((just(cast_int32_var(origin_aux_vars(0))), just(cast_int32_var(origin_aux_vars(1)))));


      // unary_sym_ternary_12    = ((just(cast_int32_var(origin_aux_vars(0))), nothing, nothing)),
      // unary_sym_ternary_3     = ((nothing, nothing, just(cast_int32_var(origin_aux_vars(0))))),
      // sym_ternary_unary_12    = ((just(cast_int32_var(origin_aux_vars(j)))) : j < 2),
      // sym_ternary_unary_3     = ((just(cast_int32_var(origin_aux_vars(2))))),



    BoolExpr slave_ternary_to_master_extra_check_expr(ForeignKeyType key_type, TempTableColVar+ origin_aux_vars, TempTableColVar+ target_aux_vars, TableVar target, AnyTable target_type, <SlaveTernTable, SlaveColumn> origin_type) {
      ## BUG BUG BUG: HERE I MUST MAKE SURE THE TARGET IS THE ACTUAL MASTER. IN THEORY A SLAVE TABLE COULD HAVE A SECOND FOREIGN KEY TO A BINARY TABLE OTHER THAN ITS MASTER
      assert target == origin_type.master;
      assert |origin_aux_vars| == 2 or |origin_aux_vars| == 3;
      assert |target_aux_vars| == 3;

      if |origin_aux_vars| == 2 {
        origin_assoc_surr_var = cast_int32_var(origin_aux_vars(0));
        target_assoc_surr_var = cast_int32_var(target_aux_vars(2));
        return neg(are_eq(origin_assoc_surr_var, target_assoc_surr_var));
      }
      else
        return or((neg(are_eq(cast_int32_var(origin_aux_vars(i)), cast_int32_var(target_aux_vars(i)))) : i <- (0, 1)));
    }


    BoolExpr slave_ternary_to_unary_extra_check_expr(TempTableColVar+ origin_aux_vars, TempTableColVar+ target_aux_vars, Maybe[LocBoolVar] maybe_target_status_var, TableVar target, AnyTable target_type, SlaveTernTable origin_type) {
      ## BUG BUG BUG: THIS FUNCTION IS PROBABLY BUGGY, BUT TRY TO TRIGGER THE BUG BEFORE TRYING TO FIX IT
      assert |origin_aux_vars| == 2 and |target_aux_vars| == 1;

      origin_aux_var = cast_int32_var(origin_aux_vars(1));
      target_aux_var = cast_int32_var(target_aux_vars(0));
      return neg(are_eq(origin_aux_var, target_aux_var));
    }


    BoolExpr extra_check_expr(ForeignKeyType key_type, AnyTable origin_type, TempTableColVar+ origin_aux_vars, TempTableColVar+ target_aux_vars, Maybe[LocBoolVar] maybe_target_status_var, TableVar target, AnyTable target_type) =
      unary_unary                               |
      unary_binary()                            |
      binary_unary()                            |
      unary_sym_binary                          |
      sym_binary_unary,     _                   = std_extra_check_expr(key_type, origin_aux_vars, target_aux_vars, target, target_type, origin_type),

      binary_ternary,       _                   = undefined, ## IMPLEMENT IMPLEMENT IMPLEMENT

      ternary_binary,       table()             = std_extra_check_expr(key_type, origin_aux_vars, target_aux_vars, target, target_type, origin_type),
      ternary_binary,       slave_tern_table()  |
                            slave_column()      = slave_ternary_to_master_extra_check_expr(key_type, origin_aux_vars, target_aux_vars, target, target_type, origin_type),

      ternary_unary(i?),    table()             = std_extra_check_expr(key_type, origin_aux_vars, target_aux_vars, target, target_type, origin_type),
      ternary_unary(2),     slave_tern_table()  = slave_ternary_to_unary_extra_check_expr(origin_aux_vars, target_aux_vars, maybe_target_status_var, target, target_type, origin_type),

      _,                    _                   = undefined; ## IMPLEMENT IMPLEMENT IMPLEMENT


    BoolExpr foreign_key_backward_check_expr(BlockForeignKey key, StaticBlock block, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])] table_var_aux_vars_map) {
      fail; ## IMPLEMENT IMPLEMENT IMPLEMENT
    }


    Nat order(BlockForeignKey key) =
      match (key.type)
        unary_unary             = 0,
        unary_binary(i?)        = i,
        unary_ternary(i?)       = i,

        binary_unary(i?)        = i,
        binary_ternary          = 0,

        ternary_unary(i?)       = i,
        ternary_binary          = 0,

        unary_sym_binary        = 0,
        sym_binary_unary        = 0,

        unary_sym_ternary_12    = 0,
        unary_sym_ternary_3     = 2,

        sym_ternary_unary_12    = 0,
        sym_ternary_unary_3     = 2,

        sym_binary_sym_ternary  = 0,
        sym_ternary_sym_binary  = 0;
  }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  Instr* updates_apply_code(StaticBlock block, [ValueStoreId] insertion_value_stores, [TableVar -> (TempTableColVar+, Maybe[LocBoolVar])] table_var_aux_vars_map, [MembVar -> (LocVar, Maybe[LocBoolVar])] memb_var_aux_vars_map, EffectsInfo effects_info) {
    ord_value_stores = isort(insertion_value_stores);
    ord_table_vars = sort_set(keys(table_var_aux_vars_map), arity(block.tables($a)) < arity(block.tables($b)));
    ord_memb_vars = isort(keys(memb_var_aux_vars_map));

    code = ();
    if ord_value_stores != () {
      code = (code | comment("Applying value store insertions"));
      for vs <- ord_value_stores {
        instr = value_store_apply(vs, block.value_stores(vs));
        code = (code | instr);
      }
    }
    if ord_table_vars != () {
      code = (code | comment("Applying table updates"));
      for v <- ord_table_vars {
        aux_vars, maybe_status_var = table_var_aux_vars_map(v);
        instr_id, action = only_pair(effects_info.tables(v));
        instrs = immediate_insert_instrs(block, v, block.tables(v), aux_vars, action);
        if maybe_status_var != nothing {
          status_var = value(maybe_status_var);
          instrs = (do_if(status_var, instrs));
        }
        code = code & instrs;
      }
    }
    if ord_memb_vars != () {
      code = (code | comment("Applying member var updates"));
      for v <- ord_memb_vars {
        aux_var, maybe_status_var = memb_var_aux_vars_map(v);
        instr = set_var(v, aux_var);
        if maybe_status_var != nothing {
          status_var = value(maybe_status_var);
          instr = do_if(status_var, (instr));
        }
        code = (code | instr);
      }
    }
    return code;


    Instr* immediate_insert_instrs(StaticBlock block, TableVar table_var, <Table, MasterBinTable, SlaveTernTable> table, TempTableColVar+ aux_vars, TableAction action) {
      aux_surr_vars = cast_int32_var_seq(aux_vars);

      if action == :update and table.keys != [] {
        owned_value_stores = ({
          owner = block.value_stores_owners(vs);
          if owner == phys_col(original_rel_var(table_var), i) {
            store_type = block.value_stores(vs);
            return just((vs, store_type));
          }
          else
            return nothing;
        } : vs @ i <- table.value_stores);
        instr = immediate_update_tuple(table_var, table, aux_surr_vars, owned_value_stores);
      }
      else
        instr = immediate_insert_tuple(table_var, table, aux_surr_vars);

      if arity(table) == 1 {
        masters_raw_columns = prg_data.masters_raw_columns(block.name);
        if masters_raw_columns(table_var, _) {
          raw_cols = isort([v : v <- masters_raw_columns(table_var, ?)]);
          capacity_var = new_unique_int32_var(:unused);
          new_capacity_var = new_unique_int32_var(:unused);
          capacity_expr = get_capacity(table_var, table);
          resize_instrs = (resize_mandatory_column(v, cast_mandatory_column(block.tables(v)), capacity_var, new_capacity_var) : v <- raw_cols);
          return (
            set_ivar32(capacity_var, capacity_expr),
            instr,
            set_ivar32(new_capacity_var, capacity_expr),
            do_if_not(are_eq(capacity_var, new_capacity_var), resize_instrs)
          );
        }
      }

      return (instr);
    }


    Instr* immediate_insert_instrs(StaticBlock block, TableVar table_var, <Column, MandatoryColumn> column, TempTableColVar+ aux_vars, TableAction action) {
      assert action == :insertion or action == :update;
      assert |aux_vars| == 2;
      key_var = cast_int32_var(aux_vars(0));
      value_var = aux_vars(1);
      return (column_insert_immediate(table_var, column, key_var, value_var, action == :update));
    }


    Instr* immediate_insert_instrs(StaticBlock block, TableVar table_var, SlaveColumn column, TempTableColVar+ aux_vars, TableAction action) {
      assert action == :insertion or action == :update;
      assert |aux_vars| == 2 or |aux_vars| == 3;
      if |aux_vars| == 2 {
        key_var = cast_int32_var(aux_vars(0));
        value_var = aux_vars(1);
        return (column_insert_immediate(table_var, column, key_var, value_var, action == :update));
      }
      else {
        arg1_var = cast_int32_var(aux_vars(0));
        arg2_var = cast_int32_var(aux_vars(1));
        value_var = aux_vars(2);
        assoc_surr_var = new_unique_int32_var(:unused);
        master_type = cast_master_bin_table(prg_data.tables(block.name)(column.master));
        return (
          // get_assoc_surr(table_var: AnyTableVar, table_type: MasterBinTable, args: (Int32Var, Int32Var)),
          set_ivar32(assoc_surr_var, get_assoc_surr(column.master, master_type, (arg1_var, arg2_var))),
          column_insert_immediate(table_var, column, assoc_surr_var, value_var, action == :update)
        );
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Instr* updates_reset_code(StaticBlock block, [ValueStoreId] insertion_value_stores) {
  // Nothing here for now
  return ();
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Bool is_optimizable(EffectsInfo effects_info) {
  for v is <- effects_info.tables {
    return false if |is| != 1;
    i, a = only_pair(is);
    return false if a != :insertion and a != :update;
    status = instr_status(i);
    return false if status.multiple;
  }
  return true;
}


## THIS IS NOT A GOOD WAY TO DO IT. IT SHOULD BE DECIDED WHILE FIGURING OUT THE EFFECTS, BECAUSE BY DOING SO
## WE COULD FOR EXAMPLE DEAL WITH THE CASE OF A MEMBER VARIABLES THAT IS SET IN BOTH BRANCHES OF AN IF STATEMENT

Bool instr_is_always_exec_once(InstrId instr_id) {
  status = instr_status(instr_id);
  return not status.optional and not status.multiple;
}

Bool memb_var_is_always_set_once([+InstrId] instr_ids) = |instr_ids| == 1 and instr_is_always_exec_once(only(instr_ids));


Bool insertion_is_forced(TableVar var, EffectsInfo effects_info) {
  _, action = only_pair(effects_info.tables(var));
  return action == :update;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

BasicInstr queue_insert_tuple_rewrite_descr(TableVar table_var, TempTableColVar+ aux_vars, Maybe[LocBoolVar] maybe_status_var, Bool forced) {
  aux_vars_strs = (native_var_decl_name(v, context=:core) : v <- aux_vars);
  text = user_repr(original_rel_var(table_var)) & ": (" & append(aux_vars_strs, ", ") & ")";
  if maybe_status_var != nothing {
    status_var = value(maybe_status_var);
    text = text & " ? " & native_var_decl_name(status_var, context=:core);
  }
  return comment(text);
}


BasicInstr queue_insert_master_tuple_rewrite_descr(TableVar table_var, TempTableColVar+ aux_vars, Maybe[LocBoolVar] maybe_status_var) {
  aux_arg_vars_strs = (native_var_decl_name(v, context=:core) : v <- take(aux_vars, 2));
  assoc_surr_var_str = native_var_decl_name(aux_vars(2), context=:core);
  text = user_repr(original_rel_var(table_var)) & ": " & append(aux_arg_vars_strs, ", ") & " @ " & assoc_surr_var_str;
  if maybe_status_var != nothing {
    status_var = value(maybe_status_var);
    text = text & " ? " & native_var_decl_name(status_var, context=:core);
  }
  return comment(text);
}


BasicInstr column_insert_deferred_rewrite_descr(TableVar table_var, TempTableColVar+ aux_vars, Maybe[LocBoolVar] maybe_status_var, Bool forced) {
  key_vars_str = native_var_decl_name(aux_vars(0), context = :core);
  key_vars_str = key_vars_str & ", " & native_var_decl_name(aux_vars(1), context = :core) if |aux_vars| == 3;
  value_var_str = native_var_decl_name(last(aux_vars), context=:core);
  text = user_repr(original_rel_var(table_var)) & ": (" & key_vars_str & " -> " & value_var_str & ")";
  if maybe_status_var != nothing {
    status_var = value(maybe_status_var);
    text = text & " ? " & native_var_decl_name(status_var, context=:core);
  }
  return comment(text);
}
