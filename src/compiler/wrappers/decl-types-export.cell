implicit prg : CompiledPrg, typedefs : [TypeName -> NeType] {
  Text decl_types_export_functs([Symbol -> DeclInterType] type_decls, [Symbol, Symbol] hierarchy) {
    type_symbs = isort(keys(type_decls));

    hierarchy_closure = flat_transitive_closure(hierarchy);
    concrete_classes = keys(type_decls);
    abstract_classes = [ts : _ ts <- hierarchy];
    all_classes = concrete_classes & abstract_classes;

    assert disjoint(concrete_classes, abstract_classes);
    assert not (ts _ <- hierarchy : not concrete_classes(ts) and not abstract_classes(ts));

    class_names = [ts -> gen_class_name(ts) : ts <- all_classes];
    export_fns_names = [ts -> decl_type_export_funct_name(ts) : ts <- all_classes];

    let class_names = class_names, export_fns_names = export_fns_names {
      // Concrete types
      code = ();
      for ts @ i <- type_symbs {
        inter_type = type_decls(ts);
        code = (code | "") if i > 0;
        code = (code | decl_type_export_funct(ts, inter_type));
      }

      // Abstract types
      for ts <- abstract_classes {
        concrete_subclasses = [sts -> type_decls(sts) : sts <- hierarchy_closure(?, ts), concrete_classes(sts)];
        code = (code | "", abstract_type_export_funct(ts, concrete_subclasses));
      }
    }

    return code;
  }
}


implicit prg : CompiledPrg, typedefs : [TypeName -> NeType], class_names : [Symbol -> String], export_fns_names : [Symbol -> String] {
  Text abstract_type_export_funct(Symbol type_symb, [Symbol -> DeclInterType] concrete_subclasses) {
    code = (
      class_names(type_symb) & " " & export_fns_names(type_symb) & "(OBJ obj) {",
      "  uint16 tag_id = get_tag_id(obj);"
    );

    for ts def <- concrete_subclasses {
      tag = match (def)
        tagged(t?, _) = t,
        _             = undefined;

      code = (
        code |
        "",
        "  if (tag_id == " & symb_id_qual_name(tag) & ")",
        "    return " & export_fns_names(ts) & "(obj);"
      );
    }

    return (
      code |
      "  internal_fail();",
      "}"
    );
  }


  Text decl_type_export_funct(Symbol type_symb, DeclInterType inter_type) {
    tmp_var = new_unique_var(:unused);
    bare_type, expr, body_header = match (inter_type)
      tuple()       |
      record()      = (inter_type, "obj", ()),
      tagged(_, t?) = (t, tmp_var, ("OBJ " & tmp_var & " = get_inner_obj(obj);"));

    class_name = class_names(type_symb);
    fn_name = export_fns_names(type_symb);

    code = decl_type_export_code(bare_type, class_name, expr, body_header);
    sign_line = class_name & " " & fn_name & "(OBJ obj) {";
    return (sign_line, code, "}");
  }


  String* decl_type_export_code(RecordInterType inter_type, String class_name, String expr, String* body_header) {
    fields = fields(inter_type);
    fields_names = adjusted_unambiguous_lower_camel_case_names(keys(fields));
    fields_vars = [v -> new_unique_var(:unused) : v _ <- fields];

    code = body_header;

    // Converting all the fields
    for l t <- fields {
      tmp_var = new_unique_var(:unused);
      code = (
        code |
        "OBJ " & tmp_var & " = lookup_field(" & expr & ", " & symb_id_qual_name(l) & ");",
        qualified_return_type(t) & " " & fields_vars(l) & ";"
      );
      code = code & export_code(t, tmp_var, fields_vars(l) & " = ");
    }

    // Instantiating and returning the object
    obj_var = new_unique_var(:unused);
    code = (code | class_name & " " & obj_var & ";");
    labels = sort_record_labels(keys(fields));
    for l <- labels {
      line = obj_var & "." & fields_names(l) & " = " & fields_vars(l) & ";";
      code = (code | line);
    }
    code = (code | "return " & obj_var & ";");
    return code;
  }


  String* decl_type_export_code(TupleInterType inter_type, String class_name, String expr, String* body_header) {
    args_types = field_types(inter_type);
    args_vars = (new_unique_var(:unused) : _ < |args_types|);

    code = body_header;

    // Converting all the fields
    for t @ i <- args_types {
      tmp_var = new_unique_var(:unused);
      code = (
        code |
        "OBJ " & tmp_var & " = get_obj_at(" & expr & ", " & _print_(i) & ");",
        qualified_return_type(t) & " " & args_vars(i) & ";"
      );
      code = code & export_code(t, tmp_var, args_vars(i) & " = ");
    }

    // Instantiating and returning the object
    return (code | "return new " & class_name & "(" & append(args_vars, ", ") & ");");
  }
}
