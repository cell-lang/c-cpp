implicit prg_data : PrgData, rel_vars_perm_map : [DBSymbol -> [RelVar -> [+Nat -> Nat]]], context : <core>, debug_mode : Bool {
  String* native_static_block_decl(StaticBlock block) {
    links_decls = (native_name(l) & " *" & native_dependee_name(l, i) & ";" : l @ i <- block.links);
    state_vars_decls = ["OBJ " & native_var_decl_name(v) & ";" : v _ <- block.state_vars];
    value_store_decls = [{
      type = native_name(t);
      return type & " " & native_var_decl_name(v) & ";";
    } : v t <- block.value_stores];
    table_decls = [native_table_type(t) & " " & native_var_decl_name(v) & ";" : v t <- block.tables];

    memb_decls = links_decls & isort(state_vars_decls) & isort(value_store_decls) & isort(table_decls);

    // ctor_code = native_ctor_code(block.name, block.links, block.state_vars, block.value_stores, block.tables, block.init_code);
    // cleanup_code = native_cleanup_function_code(block.name, block.links, block.state_vars, block.tables, block.cleanup_code);

    // // rec_ctors_code = native_rec_ctors_code(block.name, block.links);
    // // surr_obj_mappers = native_surr_obj_mappers(block.value_stores);

    // copy_state_code = native_copy_state_code(block.name, block.copy_state_code);
    // write_state_code = native_write_state_code(block);
    // set_state_code = native_set_state_code(block.name, block.set_state_code);
    // load_state_code = native_load_state_code(block.name, block.memb_var_check_exprs, block.rel_vars_load_code);

    // set_state_entry_point_code  = native_set_state_entry_point_code(block.name, block.links);
    // load_state_entry_point_code = native_load_state_entry_point_code(block.name, block.links);
    // save_state_entry_point_code = native_save_state_entry_point_code(block.name);

    // full_check_code = full_check_method_code(block);

    // methods_code = [native_user_def_method_code(block.name, id, m) : id m <- block.methods];
    // updates_code = native_updates_code(block);

    methods_decls = (native_user_method_decl(block.name, id, block.methods(id)) : id <- isort(keys(block.methods)));

    block_name = native_name(block.name);

    return join((
      ("", "", "struct " & block_name & " {"),
      ("  STATE_MEM_POOL mem_pool;"),
      indent_lines(memb_decls),
      ("};"),
      (""), auxiliary_decl(block),
      (""), methods_decls
    ));
  }


  String* native_static_block_impl(StaticBlock block) {
    // links_decls = (native_name(l) & " *" & native_dependee_name(l, i) & ";" : l @ i <- block.links);
    // state_vars_decls = ["OBJ " & native_var_decl_name(v) & ";" : v _ <- block.state_vars];
    // value_store_decls = [{
    //   type = native_name(t);
    //   return type & " " & native_var_decl_name(v) & ";";
    // } : v t <- block.value_stores];
    // table_decls = [native_table_type(t) & " " & native_var_decl_name(v) & ";" : v t <- block.tables];

    // memb_decls = links_decls & isort(state_vars_decls) & isort(value_store_decls) & isort(table_decls);

    ctor_code = native_ctor_code(block.name, block.links, block.state_vars, block.value_stores, block.tables, block.init_code);
    cleanup_code = native_cleanup_function_code(block.name, block.links, block.state_vars, block.tables, block.cleanup_code);

    // rec_ctors_code = native_rec_ctors_code(block.name, block.links);
    // surr_obj_mappers = native_surr_obj_mappers(block.value_stores);

    copy_state_code = native_copy_state_code(block.name, block.copy_state_code);
    write_state_code = native_write_state_code(block);
    set_state_code = native_set_state_code(block.name, block.set_state_code);
    load_state_code = native_load_state_code(block.name, block.memb_var_check_exprs, block.rel_vars_load_code);

    set_state_entry_point_code  = native_set_state_entry_point_code(block.name, block.links);
    load_state_entry_point_code = native_load_state_entry_point_code(block.name, block.links);
    save_state_entry_point_code = native_save_state_entry_point_code(block.name);

    full_check_code = full_check_method_code(block);

    methods_code = [native_user_def_method_code(block.name, id, m) : id m <- block.methods];
    handlers_code = native_handlers_code(block);

    handler_methods_arrays = handler_methods_arrays(block);

    handler_resol_code = handler_resolution_code(block);

    return join((
      // ("", "", "struct " & block_name & " {"),
      // ("  STATE_MEM_POOL mem_pool;"),
      // indent_lines(memb_decls),
      // ("};"),
      // (""), auxiliary_decl(block),
      (""), ctor_code,
      (""), cleanup_code,
      (""), full_check_code,
      // (""), rec_ctors_code,
      // (""), surr_obj_mappers,
      (""), copy_state_code,
      (""), write_state_code,
      (""), set_state_code,
      (""), load_state_code,
      (""), set_state_entry_point_code,
      (""), load_state_entry_point_code,
      (""), save_state_entry_point_code,
      join((("") & c : c <- isort(methods_code))),
      join((("") & c : c <- handlers_code)),
      (""), handler_methods_arrays,
      (""), handler_resol_code
      // (""), update_entry_point_code,
      // ("", ""), updater_creation_code(block),
      // (""), auxiliary_reset_code(block),
    ));
  }


  String* native_cleanup_function_code(DBSymbol auto_id, DBSymbol* links, [MembVar -> NeType] state_vars, [TableVar -> AnyTable] tables, Instr* cleanup_code) {
    target_arg = target_arg_decl(auto_id);
    aux_arg = auxiliary_arg_decl(auto_id);

    // vars_decl = gen_vars_decls(cleanup_code, []);
    // vars_decl = vars_decl & ("") if vars_decl != ();
    // body = vars_decl & native_code(cleanup_code, nothing, break_target = nothing);

    ord_state_vars = isort(keys(state_vars));
    body = (native_call("remove_from_pool", (:mem_pool, v)) : v <- ord_state_vars);

    body = (body | native_call("release_mem_pool", (:mem_pool)));

    signature = "void " & cleanup_method_name(auto_id) & "(" & target_arg & ", " & aux_arg & ") {";
    return (signature) & indent_lines(body) & ("}");
  }

  String *native_set_state_entry_point_code(DBSymbol db_type, DBSymbol* dependees) {
    method_name = set_state_entry_point_name(db_type);
    init_method_name = init_method_name(db_type);
    cleanup_method_name = cleanup_method_name(db_type);
    set_state_method_name = set_state_proc_name(db_type);
    db_type_name = native_name(db_type);
    aux_type_name = native_auxiliary_name(db_type);

    dep_names = (native_dependee_name(t, i) : t @ i <- dependees);
    dep_aux_names = (aux_var_decl_name(linked_db_var(i)) : _ @ i <- dependees);
    dep_args = (", target->" & dep_names(i) & ", auxiliary->" & dep_aux_names(i) : _ @ i <- dependees);

    return (
      "bool " & method_name & "(" & db_type_name & " *target, " & aux_type_name & " *auxiliary, OBJ new_state, ENV &env) {",
      "  " & db_type_name & " new_inst;",
      "  " & aux_type_name & " new_aux_inst;",
      "  ",
      "  switch_mem_stacks();",
      "  ",
      "  " & init_method_name & "(&new_inst, &new_aux_inst" & append(dep_args) & ", env);",
      "  ",
      "  bool succeeded = " & set_state_method_name & "(&new_inst, new_state);",
      "  ",
      "  if (succeeded) {",
      "    " & cleanup_method_name & "(target, auxiliary);",
      "    *target = new_inst;",
      "    *auxiliary = new_aux_inst;",
      "  }",
      "  else {",
      "    " & cleanup_method_name & "(&new_inst, &new_aux_inst);",
      "  }",
      "  ",
      "  unswitch_mem_stacks();",
      "  clear_unused_mem();",
      "  ",
      "  return succeeded;",
      "}"
    );
  }

  String* native_load_state_entry_point_code(DBSymbol db_type, DBSymbol* dependees) {
    method_name = load_state_entry_point_name(db_type);
    init_method_name = init_method_name(db_type);
    cleanup_method_name = cleanup_method_name(db_type);
    load_fn_name = load_state_proc_name(db_type);
    db_type_name = native_name(db_type);
    aux_type_name = native_auxiliary_name(db_type);

    dep_names = (native_dependee_name(t, i) : t @ i <- dependees);
    dep_aux_names = (aux_var_decl_name(linked_db_var(i)) : _ @ i <- dependees);
    dep_args = (", target->" & dep_names(i) & ", auxiliary->" & dep_aux_names(i) : _ @ i <- dependees);

    return (
      "OBJ " & method_name & "(OBJ fname, " & db_type_name & " *target, " & aux_type_name &" *auxiliary, ENV &env) {",
      "  " & db_type_name & " new_inst;",
      "  " & aux_type_name &" new_aux_inst;",
      "",
      "  switch_mem_stacks();",
      "",
      "  const char *c_fname = obj_to_str(fname);",
      "  FILE *fp = fopen(c_fname, \"r\");",
      "  if (fp == NULL) {",
      "    //## SAVE ERROR INFORMATION INSIDE AUXILIARY DATA STRUCTURE",
      "    //## DESTROY THE STACK SECTION",
      "    return make_bool(false);",
      "  }",
      "",
      "  " & init_method_name & "(&new_inst, &new_aux_inst" & append(dep_args) & ", env);",
      "",
      "  READ_FILE_STATE read_state;",
      "  read_state.fp = fp;",
      "  bool succeeded = " & load_fn_name & "(&new_inst, &new_aux_inst, read_file, &read_state);",
      "  fclose(fp);",
      "",
      "  if (succeeded) {",
      "    " & cleanup_method_name & "(target, auxiliary);",
      "    *target = new_inst;",
      "    *auxiliary = new_aux_inst;",
      "  }",
      "  else {",
      "    " & cleanup_method_name & "(&new_inst, &new_aux_inst);",
      "  }",
      "",
      "  unswitch_mem_stacks();",
      "  clear_unused_mem();",
      "",
      "  return make_bool(succeeded);",
      "}"
    );
  }

  String* native_save_state_entry_point_code(DBSymbol db_type) {
    method_name = save_state_entry_point_name(db_type);
    db_type_name = native_name(db_type);
    aux_type_name = native_auxiliary_name(db_type);
    write_fn_name = write_state_proc_name(db_type);

    return (
      "OBJ " & method_name & "(OBJ fname, " & db_type_name & " *target, " & aux_type_name & " *auxiliary) {",
      "  switch_mem_stacks();",
      "",
      "  const char *c_fname = obj_to_str(fname);",
      "  FILE *fp = fopen(c_fname, \"w\");",
      "  if (fp == NULL) {",
      "    //## SAVE ERROR INFORMATION SOMEWHERE",
      "    unswitch_mem_stacks();",
      "    clear_unused_mem();",
      "    return make_bool(false);",
      "  }",
      "",
      "",
      "  WRITE_FILE_STATE write_state;",
      "  write_state.fp = fp;",
      "  write_state.success = true;",
      "  " & write_fn_name & "(target, &write_state);",
      "  fclose(fp);",
      "",
      "  unswitch_mem_stacks();",
      "  clear_unused_mem();",
      "",
      "  return make_bool(write_state.success);",
      "}"
    );
  }


  String* native_ctor_code(DBSymbol name, DBSymbol* dependees, [MembVar -> NeType] state_vars, [ValueStoreId -> ValueStoreType] value_stores, [TableVar -> AnyTable] tables, Instr* init_code) {
    body : String*;

    target_name = auto_or_db_arg_name;
    aux_name = db_auxiliary_arg_name;
    target_arg = target_arg_decl(name);
    aux_arg = auxiliary_arg_decl(name);
    dependees_names = (native_dependee_name(t, i) : t @ i <- dependees);
    dep_aux_names = (aux_var_decl_name(linked_db_var(i)) : _ @ i <- dependees);
    dependees_args = (", " & native_name(t) & " *" & dependees_names(i) & ", " & native_auxiliary_name(t) & " *" & dep_aux_names(i) : t @ i <- dependees);

    ord_value_stores = isort(keys(value_stores));

    tables_in_init_order = sort_by_key(
      [(v, t) : v t <- tables],
      match ($(1))
        table()             |
        master_bin_table()  = 0,
        slave_tern_table()  |
        column()            |
        mandatory_column()  |
        slave_column()      = 1
    );

    // Local variables declaration
    body = gen_vars_decls(init_code, []);

    // Memory pool initialization
    body = (body | "") if body != ();
    body = (body | "init_mem_pool(&" & target_name & "->mem_pool);");

    // Dependee links initialization
    if dependees != () {
      body = (body | "");
      body = body & (target_name & "->" & dependees_names(i) & " = " & dependees_names(i) & ";" : i < |dependees|);
      body = (body | "");
      body = body & (aux_name & "->" & dep_aux_names(i) & " = " & dep_aux_names(i) & ";" : i < |dependees|);
    }

    // Member variables initialization
    if init_code != () {
      body = body & ("") & native_code(init_code, nothing, break_target = nothing);
    }

    // Value stores initialization
    if ord_value_stores != () {
      code = ({
        init_method_name = native_value_store_method_prefix(value_stores(vs_id)) & "_init";
        return native_call(init_method_name, (vs_id, :mem_pool));
      } : vs_id <- ord_value_stores);

      body = body & ("") & code;
    }

    // Tables initialization
    if tables_in_init_order != () {
      code = ({
      //   value_stores = match (t)
      //     table()             = if t.symmetric then drop(t.value_stores, 1) else t.value_stores,
      //     master_bin_table()  = if t.symmetric then undefined else t.value_stores,
      //     slave_tern_table()  = if t.symmetric then undefined else t.value_stores,
      //     column()            = (t.value_store),
      //     slave_column()      = ();
      //   arg_list = append(("this::" & native_surr_obj_mapper_name(vs) : vs <- value_stores), ", ");
      //   arg_list = match (t)
      //     slave_tern_table()  = native_var_ref_name(t.master) & ", " & arg_list,
      //     _                   = arg_list;
      //   return native_var_ref_name(v) & " = new " & native_table_type(t) & "(" & arg_list & ");";

        init_method_name = match (t)
          slave_tern_table()  = "bin_table_init",
          _                   = native_table_method_prefix(t) & "_init";

        extra_args = match (t)
          mandatory_column()  = (t.master),
          _                   = ();

        return native_call(init_method_name, (extra_args | v, :mem_pool));
      } : v, t <- tables_in_init_order);

      body = body & ("") & code;
    }

    // Pending update variables initialization
    if state_vars != [] {
      ord_state_vars = isort(keys(state_vars));
      pending_aux_vars_init_code = (native_var_ref_name(pending_state_var(bare_id(v))) & " = make_blank_obj();" : v <- ord_state_vars);
      body = body & ("") & pending_aux_vars_init_code;
    }

    if dependees != () {
      // Dependees' message variables initialization
      msg_vars_init_code = (dependee_msg_var_ref_name(linked_db_var(i)) & " = make_blank_obj();" : i < |dependees|);

      // Dependees' apply codes initialization
      apply_code_vars_init_code = (dependee_apply_code_var_ref_name(linked_db_var(i)) & " = -1;" : i < |dependees|);

      body = body & ("") & msg_vars_init_code & ("") & apply_code_vars_init_code;
    }

    // Value stores' auxiliary data structures initialization
    if ord_value_stores != () {
      code = ({
        init_method_name = native_value_store_method_prefix(value_stores(vs_id)) & "_aux_init";
        return native_call(init_method_name, (updater_var_ref_name(vs_id)));
      } : vs_id <- ord_value_stores);

      body = body & ("") & code;
    }

    // Tables' auxiliary data structures initialization
    if tables_in_init_order != () {
      code = ({
      //   value_stores = match (t)
      //     table()             = if t.symmetric then drop(t.value_stores, 1) else t.value_stores,
      //     master_bin_table()  = if t.symmetric then undefined else t.value_stores,
      //     slave_tern_table()  = if t.symmetric then undefined else t.value_stores,
      //     column()            = (t.value_store),
      //     slave_column()      = ();
      //   arg_list = append(("this::" & native_surr_obj_mapper_name(vs) : vs <- value_stores), ", ");
      //   arg_list = match (t)
      //     slave_tern_table()  = native_var_ref_name(t.master) & ", " & arg_list,
      //     _                   = arg_list;
      //   return native_var_ref_name(v) & " = new " & native_table_type(t) & "(" & arg_list & ");";

        prefix = match (t)
          mandatory_column()  = native_column_method_prefix(t.repr),
          _                   = native_table_method_prefix(t);
        init_method_name = prefix & "_aux_init";

        return native_call(init_method_name, (pending_updates_var_ref_name(v), :mem_pool));
      } : v, t <- tables_in_init_order);

      body = body & ("") & code;
    }

    // Putting it all together
    signature = "void " & init_method_name(name) & "(" & target_arg & ", " & aux_arg & append(dependees_args) & ", ENV &" & env_arg_name & ") {";
    return (signature) & indent_lines(body) & ("}");
  }


  // String* native_rec_ctors_code(DBSymbol block_name, DBSymbol* dependees) {
  //   obj_type = obj_type_name;
  //   env_type = env_type_name;
  //   target_name = auto_or_db_arg_name;
  //   target_type_name = native_name(block_name);
  //   env_arg = env_arg_name;
  //   init_method = init_method_name(block_name);
  //   full_check_method = full_check_proc_name(block_name);

  //   dependees_args = (native_dependee_name(t, i) : t @ i <- dependees);

  //   formal_target_arg = target_type_name & " *" & target_name;
  //   formal_state_arg = obj_type & " state";
  //   formal_reader_arg = reader_type_name & " *reader";
  //   formal_env_arg = env_type & " &" & env_arg;
  //   formal_dependees_args = (native_name(t) & " " & dependees_args(i) : t @ i <- dependees);

  //   formal_set_state_args = append((formal_target_arg) & formal_dependees_args & (formal_state_arg, formal_env_arg), ", ");
  //   formal_load_state_args = append((formal_target_arg) & formal_dependees_args & (formal_reader_arg, formal_env_arg), ", ");

  //   init_method_call_args = append((target_name) & (dependees_args | env_arg), ", ");

  //   return (
  //     "bool " & init_set_state_method_name(block_name) & "(" & formal_set_state_args & ") {",
  //     "  " & init_method & "(" & init_method_call_args & ");",
  //     "  if (!" & set_state_proc_name(block_name) & "(" & target_name & ", state)) {",
  //     "    return false;",
  //     "  }",
  //     "  if (!" & full_check_method & "(" & target_name & ")) {",
  //     "    return false;",
  //     "  }",
  //     "  return true;",
  //     "}",
  //     "",
  //     "bool " & init_load_state_method_name(block_name) & "(" & formal_load_state_args & ") {",
  //     "  " & init_method & "(" & init_method_call_args & ");",
  //     "  if (!" & load_state_proc_name(block_name) & "(" & target_name & ", reader)) {",
  //     "    return false;",
  //     "  }",
  //     "  if (!" & full_check_method & "(" & target_name & ")) {",
  //     "    return false;",
  //     "  }",
  //     "  return true;",
  //     "}"
  //   );
  // }


  // String* native_surr_obj_mappers([ValueStoreId -> ValueStoreType] value_stores) {
  //   return join(intermix((surr_obj_mapper(id, type) : id, type <- isort(value_stores)), ("")));


  //   String* surr_obj_mapper(ValueStoreId id, ValueStoreType type) {
  //     name = native_surr_obj_mapper_name(id);
  //     vs_name = native_var_ref_name(id);
  //     sign = "private OBJ " & name & "(int surr) {";
  //     body = "  return " & match (type)
  //       object | integer        = vs_name & ".surrToObjValue(surr);",
  //       mono_tagged_integer(s?) = "Builder.createTaggedIntObj(" & symb_id_name(s) & ", " & vs_name & ".surrToValue(surr));";
  //     return (sign, body, "}");
  //   }
  // }


  // (String, String*) native_cleanup_code(DBSymbol name, Instr* cleanup_code) {
  //   cleanup_body = native_code(cleanup_code, nothing);
  //   cleanup_sgn = "void " & cleanup_method_name(name) & "(" & native_name(name) & " *self)";
  //   cleanup_decl = cleanup_sgn & ";";
  //   cleanup_proc = (cleanup_sgn & " {") & indent_lines(cleanup_body) & ("}");
  //   return (cleanup_decl, cleanup_proc);
  // }


  String* native_copy_state_code(DBSymbol name, Instr* code) {
    vars_decls = gen_vars_decls(code, []);
    body = vars_decls & ("" if vars_decls != ()) & native_code(code, nothing, break_target = nothing);
    sgn = obj_type_name & " " & copy_state_proc_name(name) & "(" & native_name(name) & " *" & auto_or_db_arg_name & ") {";
    return (sgn) & indent_lines(body) & ("}");
  }

  String* native_write_state_code(StaticBlock block) {
    has_rel_vars = block.tables != [];

    code = (
      "void " & write_state_proc_name(block.name) & "(" & native_name(block.name) & " *" & auto_or_db_arg_name & ", WRITE_FILE_STATE *write_state) {",
      "  " & write_str_proc_name & "(write_state, \"( \");"
    );

    first = true;

    state_vars = isort(keys(block.state_vars));
    for v @ i <- state_vars {
      code = (code | "  " & write_str_proc_name & "(write_state, \"  \");") if not first;
      code = (code |
        "  " & write_symb_proc_name & "(write_state, " & symb_id_name(bare_id(v)) & ");",
        "  " & write_str_proc_name & "(write_state, \": \");",
        "  " & write_obj_proc_name & "(write_state, " & native_var_ref_name(v) & ");",
        if i < |state_vars| - 1 or has_rel_vars
          then "  " & write_str_proc_name & "(write_state, \",\\n\");"
          else "  " & write_str_proc_name & "(write_state, \"\\n\");"
      );
      first = false;
    }

    tables_by_relvar = group_by(keys(block.tables), logical_rel_var(original_rel_var($)));

    relvar_arity = [logical_rel_var(original_rel_var(v)) -> arity(t) : v t <- block.tables];
    ord_relvars = sort_by_key(keys(relvar_arity), relvar_arity($));

    for rv @ i <- ord_relvars {
      tvs = tables_by_relvar(rv);

      symb = symb_id_name(bare_id(rv));
      ord_table_vars = isort(tvs);
      tables = append((native_var_ref_name(tv) : tv <- ord_table_vars), ", ");
      indent_first_line = _print_(not first);
      write_separator = _print_(i < |tables_by_relvar| - 1);
      perm = rel_vars_perm_map(block.name)(rv);
      symmetric = only([
        match (block.tables(tv))
          column()              |
          mandatory_column()    |
          slave_column()        = false,
          table() t?            |
          master_bin_table() t? |
          slave_tern_table() t? = t.symmetric
        : tv <- tvs
      ]);

      perm_args = if symmetric
        then ()
        else match (|perm|)
          1   = (),
          2   = if perm == [0 -> 1, 1 -> 0] then ("true") else ("false"),
          3   = (_print_(perm(j)) : j < 3);

      // are_slave_columns = only([
      //   match (block.tables(tv))
      //     slave_column()  = true,
      //     _               = false
      //   : tv <- tvs
      // ]);

      // if are_slave_columns {
      //   masters = (
      //     match (block.tables(v))
      //       slave_column() c? = c.master,
      //       _                 = undefined
      //     : v <- ord_table_vars
      //   );
      //   masters_array = ", new MasterBinaryTable[] {" & append((native_var_ref_name(v) : v <- masters), ", ") & "}";
      // }
      // else
      //   masters_array = "";


      code = (code | "  " & write_str_proc_name & "(write_state, \"  \");") if not first;
      code = (code |
        "  " & write_symb_proc_name & "(write_state, " & symb & ");",
        "  " & write_str_proc_name & "(write_state, \": [\");"
      );

      for tv @ j <- ord_table_vars {
        table = block.tables(tv);
        method_name = native_table_method_prefix(table) & "_write";
        method_name = match (table)
          slave_column()  = "slave_" & method_name,
          _               = method_name;
        value_store_args = join(((native_surr_to_obj_method_name(block.value_stores(v)), v) : v <- table_value_stores(table)));

        comma_sep = match (table)
          table()             = { arity = arity(table);
                                  return true if arity == 1;
                                  return false if arity == 3;
                                  return false if table.symmetric;
                                  assert perm == [0 -> 0, 1 -> 1] or perm == [0 -> 1, 1 -> 0];
                                  key = if perm == [0 -> 0, 1 -> 1] then [0] else [1];
                                  return table.keys(key);
                                },
          master_bin_table()  = false,
          slave_tern_table()  = false,
          column()            |
          mandatory_column()  |
          slave_column()      = true;

        ad_hoc_args_1 = match (table)
          mandatory_column()  |
          slave_column()      |
          slave_tern_table()  = (table.master),
          _                   = ();

        ad_hoc_args_2 = match (table)
          table()             = (comma_sep if arity(table) == 2 and not table.symmetric),
          _                   = ();

        instr = native_call(method_name, ("write_state") & ad_hoc_args_1 & (tv) & value_store_args & ad_hoc_args_2 & perm_args);

        if j > 0 {
          exprs = ({
            prev_table_var = ord_table_vars(k);
            prev_table = block.tables(prev_table_var);
            get_count_expr = native_get_count_expr(prev_table_var, prev_table, (nothing : _ < arity(prev_table)));
            return get_count_expr & " > 0";
          } : k < j);
          get_count_expr = native_get_count_expr(tv, table, (nothing : _ < arity(table)));
          sep = if comma_sep then "," else ";";
          code = (code |
            "  if (" & get_count_expr & " > 0) {",
            "    if (" & append(exprs, " || ") & ")",
            "      write_str(write_state, \"" & sep & "\");",
            "    " & instr,
            "  }"
          );
        }
        else
          code = (code | "  " & instr);
      }

      maybe_comma = if i < |tables_by_relvar| - 1 then "," else "";
      code = (code | "  " & write_str_proc_name & "(write_state, \"\\n  ]" & maybe_comma & "\\n\");");

      first = false;
    }

    code = (code |
      "  " & write_str_proc_name & "(write_state, \")\\n\");",
      "  " & finish_write_proc_name & "(write_state);",
      "}"
    );

    return code;
  }


  String* native_set_state_code(DBSymbol name, Instr* code) {
    //updater_init_call = native_method_call("this", updater_init_proc_name(name), ());
    vars_decls = gen_vars_decls(code, []);
    //body = vars_decls & ("" if vars_decls != (), updater_init_call) & native_code(code, nothing);
    body = vars_decls & native_code(code, nothing, break_target = nothing);
    sgn = "bool " & set_state_proc_name(name) & "(" & native_name(name) & " *" & auto_or_db_arg_name & ", " & obj_type_name & " a0) {";
    return (sgn) & indent_lines(body) & ("}");
  }


  String* native_load_state_code(DBSymbol name, [MembVar -> BoolExpr] memb_vars_check_exprs, [RelVar -> (LocVar+, Instr*, Instr+, Instr*)] rel_vars_load_code) {
    code_blocks = ();
    for _ info <- rel_vars_load_code {
      _, ec, lc, xc = info;
      code_blocks = (code_blocks | ec, lc, xc);
    }
    vars_decls = gen_all_vars_decls(code_blocks, []);

    header = (
      "bool " & load_state_proc_name(name) & "(" & target_arg_decl(name) & ", " & auxiliary_arg_decl(name) & ", uint32 (*read)(void *, uint8 *, uint32), void *read_state) {",
    ) & indent_lines(vars_decls) & (
      "",
      "  SURR_SET surr_set;",
      "  surr_set_init(&surr_set);",
      "",
      "  PARSER parser;",
      "  init_parser(&parser, read, read_state);",
      "",
      "  if (consume_non_ws_char(&parser, '[')) {",
      "    return consume_non_ws_char(&parser, ']');",
      "  }",
      "",
      "  if (!consume_non_ws_char(&parser, '(')) {",
      "    return false;",
      "  }",
      "",
      "  uint16 field;",
      "  while (read_label(&parser, &field)) {",
      "    switch (field) {"
    );

    footer = (
      "",
      "      default:",
      "        if (!skip_value(&parser)) {",
      "          return false;",
      "        }",
      "    }",
      "",
      "    if (!consume_non_ws_char(&parser, ','))",
      "      break;",
      "  }",
      "",
      "  return consume_non_ws_char(&parser, ')');",
      "}"
    );

    memb_vars_cases = (
      indent_lines(native_load_state_case(v, e), 3) : v, e <- isort(memb_vars_check_exprs)
    );

    rel_vars_cases = ({
      vars, entry_instrs, loop_instrs, exit_instrs = rel_vars_load_code(rv);
      case = match (vars)
        (v?)            = native_load_state_case(rv, v, entry_instrs, loop_instrs, exit_instrs),
        (v1?, v2?)      = native_load_state_case(rv, v1, v2, entry_instrs, loop_instrs, exit_instrs),
        (v1?, v2?, v3?) = native_load_state_case(rv, v1, v2, v3, entry_instrs, loop_instrs, exit_instrs);
      return indent_lines(case, 3);
    } : rv <- isort(keys(rel_vars_load_code)));

    return header & join(intermix(memb_vars_cases & rel_vars_cases, (""))) & footer;


    String* native_load_state_case(MembVar var, BoolExpr guard_expr) {
      symb_str = symb_id_name(bare_id(var));
      var_str = native_var_ref_name(var);
      guard_expr_str = native_expr(guard_expr);
      pool_ref_str = native_var_ref_name(:mem_pool);

      return (
        "case " & symb_str & ":",
        "  if (!parse_obj(&parser, &v0)) {",
        "    return false;",
        "  }",
        "  remove_from_pool(" & pool_ref_str & ", " & var_str & ");",
        "  " & var_str & " = copy_to_pool(" & pool_ref_str & ", v0);",
        "  if (!(" & guard_expr_str & ")) {",
        "    return false;",
        "  }",
        "  break;"
      );
    }


    String* native_load_state_case(RelVar rel_var, LocVar var, Instr* entry_code, Instr+ loop_code, Instr* exit_code) {
      symb_str = symb_id_name(bare_id(rel_var));
      var_str = native_var_ref_name(var);

      entry_code_text = indent_lines(native_code(entry_code, nothing, break_target = nothing), 2);
      loop_code_text = indent_lines(native_code(loop_code, nothing, break_target = nothing), 3);
      exit_code_text = indent_lines(native_code(exit_code, nothing, break_target = nothing), 1);

      return (
        "case " & symb_str & ":",
        "  if (!consume_non_ws_char(&parser, '['))",
        "    return false;",
        "  if (!consume_non_ws_char(&parser, ']')) {"
      ) & entry_code_text & (
        "    for ( ; ; ) {",
        "      if (!parse_obj(&parser, &" & var_str & "))",
        "        return false;"
      ) & loop_code_text & (
        "      if (!consume_non_ws_char(&parser, ',')) {",
        "        if (!consume_non_ws_char(&parser, ']'))",
        "          return false;",
        "        break;",
        "      }",
        "      if (consume_non_ws_char(&parser, ']'))",
        "        break;",
        "    }",
        "  }"
      ) & exit_code_text & (
        "  break;"
      );
    }


    String* native_load_state_case(RelVar rel_var, LocVar var1, LocVar var2, Instr* entry_code, Instr+ loop_code, Instr* exit_code) {
      symb_str = symb_id_name(bare_id(rel_var));
      var1_str = native_var_ref_name(var1);
      var2_str = native_var_ref_name(var2);

      entry_code_text = indent_lines(native_code(entry_code, nothing, break_target = nothing), 2);
      loop_code_text_1 = indent_lines(native_code(loop_code, nothing, break_target = nothing), 4);
      loop_code_text_2 = indent_lines(native_code(loop_code, nothing, break_target = nothing), 4);
      exit_code_text = indent_lines(native_code(exit_code, nothing, break_target = nothing), 1);

      return (
        "case " & symb_str & ":",
        "  if (!consume_non_ws_char(&parser, '['))",
        "    return false;",
        "  if (!consume_non_ws_char(&parser, ']')) {"
      ) & entry_code_text & (
        // "    parser.bookmark();", ## IMPLEMENT IMPLEMENT IMPLEMENT
        "    if (!parse_obj(&parser, &" & var1_str & "))",
        "      return false;",
        "    if (consume_non_ws_chars(&parser, '-', '>')) {",
        "      if (!parse_obj(&parser, &" & var2_str & "))",
        "        return false;",
        "      for ( ; ; ) {"
        // "        parser.failAtBookmark();" ## IMPLEMENT IMPLEMENT IMPLEMENT
      ) & loop_code_text_1 & (
        "        if (!consume_non_ws_char(&parser, ',') || next_non_ws_char_is(&parser, ']'))",
        "          break;",
        "",
        // "        parser.bookmark();", ## IMPLEMENT IMPLEMENT IMPLEMENT
        "        if (!parse_obj(&parser, &" & var1_str & "))",
        "          return false;",
        "        if (!consume_non_ws_chars(&parser, '-', '>'))",
        "          return false;",
        "        if (!parse_obj(&parser, &" & var2_str & "))",
        "          return false;",
        "      }",
        "    }",
        "    else {",
        "      if (!consume_non_ws_char(&parser, ','))",
        "        return false;",
        "      if (!parse_obj(&parser, &" & var2_str & "))",
        "        return false;",
        "      for ( ; ; ) {"
        // "        parser.failAtBookmark();" ## IMPLEMENT IMPLEMENT IMPLEMENT
      ) & loop_code_text_2 & (
        "        if (!consume_non_ws_char(&parser, ';') || next_non_ws_char_is(&parser, ']'))",
        "          break;",
        // "        parser.bookmark();",
        "        if (!parse_obj(&parser, &" & var1_str & "))",
        "          return false;",
        "        if (!consume_non_ws_char(&parser, ','))",
        "          return false;",
        "        if (!parse_obj(&parser, &" & var2_str & "))",
        "          return false;",
        "      }",
        "    }",
        "  }",
        "  if (!consume_non_ws_char(&parser, ']'))",
        "    return false;"
      ) & exit_code_text & (
        "  break;"
      );
    }


    String* native_load_state_case(RelVar rel_var, LocVar var1, LocVar var2, LocVar var3, Instr* entry_code, Instr+ loop_code, Instr* exit_code) {
      symb_str = symb_id_name(bare_id(rel_var));
      var1_str = native_var_ref_name(var1);
      var2_str = native_var_ref_name(var2);
      var3_str = native_var_ref_name(var3);

      entry_code_text = indent_lines(native_code(entry_code, nothing, break_target = nothing), 2);
      loop_code_text = indent_lines(native_code(loop_code, nothing, break_target = nothing), 3);
      exit_code_text = indent_lines(native_code(exit_code, nothing, break_target = nothing), 1);

      return (
        "case " & symb_str & ":",
        "  if (!consume_non_ws_char(&parser, '['))",
        "    return false;",
        "  if (!consume_non_ws_char(&parser, ']')) {"
      ) & entry_code_text & (
        "    for (int i=0 ; !next_non_ws_char_is(&parser, ']') ; i++) {",
        // "      parser.bookmark();",
        "      if (!parse_obj(&parser, &" & var1_str & "))",
        "        return false;",
        "      if (!consume_non_ws_char(&parser, ','))",
        "        return false;",
        "      if (!parse_obj(&parser, &" & var2_str & "))",
        "        return false;",
        "      if (!consume_non_ws_char(&parser, ','))",
        "        return false;",
        "      if (!parse_obj(&parser, &" & var3_str & "))",
        "        return false;"
        // "      parser.failAtBookmark();"
      ) & loop_code_text & (
        "      if (!consume_non_ws_char(&parser, ';')) {",
        "        if (i == 0)",
        "          return false;",
        "        else",
        "          break;",
        "      }",
        "    }",
        "  }",
        "  if (!consume_non_ws_char(&parser, ']'))",
        "    return false;"
      ) & exit_code_text & (
        "  break;"
      );
    }
  }


  // String* update_entry_point(DBSymbol block_name) {
  //   target_name = auto_or_db_arg_name;
  //   aux_name = db_auxiliary_arg_name;
  //   main_handler_args = (target_name, aux_name, "msg", "env");
  //   apply_method_args = (target_name, aux_name, "code");
  //   body = (
  //     // "int depth = get_call_stack_depth();",
  //     "  switch_mem_stacks();",
  //     "",
  //     "try {",
  //     "  //## SET FLAG SIGNALLING WE'RE INSIDE A TRANSACTION",
  //     "  int code = " & update_name(block_name, main_handler) & "(" & append(main_handler_args, ", ") & ");",
  //     "  //## RESET TRANSACTION FLAG",
  //     "  " & native_apply_and_reset_method_name(block_name, main_handler) & "(" & append(apply_method_args, ", ") & ");",
  //     "  //## CLEAR THE ERROR MESSAGE",
  //     "  unswitch_mem_stacks();",
  //     "  clear_unused_mem();",
  //     "  return true;",
  //     "}",
  //     "catch (...) {",
  //     "  //## RESET TRANSACTION FLAG",
  //     "  //## " & auxiliary_reset_proc_name(block_name) & "(" & aux_name & ");",
  //     "  //## CLEAR THE ERROR MESSAGE",
  //     "  unswitch_mem_stacks();",
  //     "  clear_unused_mem();",
  //     "  return false;",
  //     "}"
  //   );

  //   name = update_entry_point_name(block_name);
  //   updater_type = native_auxiliary_name(block_name);
  //   formal_args = (target_arg_decl(block_name), auxiliary_arg_decl(block_name), obj_type_name & " msg", env_arg_decl);
  //   sgn = "bool " & name & "(" & append(formal_args, ", ") & ") {";
  //   return (sgn) & indent_lines(body) & ("}");
  // }


  String* full_check_method_code(StaticBlock block) {
    keys = [(v, t, k) : v t <- block.tables, needs_keys_check(t), k <- keys(t)];
    ord_keys = sort_by_key(keys, arity($(1)));
    keys_check_code = join(({
      method_name = key_check_method_name(t, k);
      return (
        "if (!" & native_call_expr(method_name, (v)) & ")",
        "  return false;"
      );
    } : v, t, k <- ord_keys));

    foreign_keys_check_code = native_code(block.foreign_keys_check_code, nothing, break_target = nothing);
    vars_decls = gen_vars_decls(block.foreign_keys_check_code, []);

    sections = (vars_decls, keys_check_code, foreign_keys_check_code, ("return true;"));
    sections = (s : s <- sections, s != ());
    body = join(intermix(sections, ("")));

    sgn = "bool " & full_check_proc_name(block.name) & "(" & target_arg_decl(block.name) & ") {";
    return (sgn) & indent_lines(body) & ("}");


    String key_check_method_name(AnyTable table, [+Nat] key) =
      table()             = key_check_method_names((arity(table), key), !),
      master_bin_table()  = master_bin_table_key_check_method_names(key, !),
      slave_tern_table()  = slave_tern_table_key_check_method_names(key, !),
      column()            |
      slave_column()      = undefined;


    [(NzNat, [+Nat]) -> String] key_check_method_names = [
      (2, [0])    -> "bin_table_col_1_is_key",
      (2, [1])    -> "bin_table_col_2_is_key",
      (3, [2])    -> "tern_table_col_3_is_key",
      (3, [0, 1]) -> "tern_table_cols_12_are_key",
      (3, [0, 2]) -> "tern_table_cols_13_are_key",
      (3, [1, 2]) -> "tern_table_cols_23_are_key"
    ];

    [[+Nat] -> String] master_bin_table_key_check_method_names = [
      [0] -> "master_bin_table_col_1_is_key",
      [1] -> "master_bin_table_col_2_is_key"
    ];

    [[+Nat] -> String] slave_tern_table_key_check_method_names = [
      [0, 1] -> "slave_tern_table_cols_12_are_key",
      [2]    -> "slave_tern_table_col_3_is_key"
    ];


    True  needs_keys_check(<Table, MasterBinTable, SlaveTernTable>) = true;
    False needs_keys_check(<MandatoryColumn, Column, SlaveColumn>) = false; //## NOT SURE ABOUT THIS ONE
  }


  String* auxiliary_decl(StaticBlock block) {
    linked_updaters_decls = (
      native_auxiliary_name(l) & " *" & aux_var_decl_name(linked_db_var(i)) & ";"
      : l @ i <- block.links
    );

    dep_msg_vars_decls = (
      obj_type_name & " " & dependee_msg_var_decl_name(linked_db_var(i)) & ";" : i < |block.links|
    );

    dep_apply_code_vars_decls = (
      "int " & dependee_apply_code_var_decl_name(linked_db_var(i)) & ";" : i < |block.links|
    );

    vars_decls = (
      obj_type_name & " " & native_var_decl_name(pending_state_var(bare_id(v))) & ";"
      : v, _ <- isort(block.state_vars)
    );

    stores_decls = (
      native_updater_type(t) & " " & aux_var_decl_name(vs) & ";"
      : vs, t <- isort(block.value_stores)
    );

    tables_decls = (
      native_table_aux_type(t) & " " & pending_updates_var_decl_name(v) & ";"
      : v, t <- isort(block.tables)
    );

    membs_decls = linked_updaters_decls & dep_msg_vars_decls & dep_apply_code_vars_decls & vars_decls & stores_decls & tables_decls;

    return ("struct " & native_auxiliary_name(block.name) & " {",) & indent_lines(membs_decls) & ("};");
  }


  // String* updater_creation_code(StaticBlock block) {
  //   linked_updaters_init_code = (
  //     updater_var_ref_name(linked_db_var(i)) & " = l" & _print_(i) & ";"
  //     : i < |block.links|
  //   );

  //   dep_msg_vars_init_code = (dependee_msg_var_ref_name(linked_db_var(i)) & " = null;" : i < |block.links|);
  //   dep_apply_code_vars_init_code = (dependee_apply_code_var_ref_name(linked_db_var(i)) & " = 0;" : i < |block.links|);

  //   var_ids = (bare_id(v) : v <- isort(keys(block.state_vars)));
  //   init_vars_code = (native_var_ref_name(pending_state_var(id)) & " = make_blank_obj();" : id <- var_ids);

  //   value_stores_init_code = (
  //     native_new_call(updater_var_ref_name(vs), native_updater_type(t), (vs))
  //     : vs, t <- isort(block.value_stores)
  //   );

  //   ord_tables = ((v, block.tables(v)) : v <- sort_by_key(keys(block.tables), arity(block.tables($))));
  //   tables_init_code = ({
  //     value_stores = match (t)
  //       table()            = if t.symmetric then drop(t.value_stores, 1) else t.value_stores,
  //       master_bin_table() = if t.symmetric then undefined else t.value_stores,
  //       slave_tern_table() = if t.symmetric then undefined else t.value_stores,
  //       column()           = (t.value_store),
  //       slave_column()     = t.value_stores;

  //     other_args = match (t)
  //       slave_column()  = (pending_updates_var_ref_name(t.master)),
  //       _               = ();

  //     return native_new_call(
  //       pending_updates_var_ref_name(v),
  //       native_table_aux_type(t),
  //       ("\"" & user_repr(original_rel_var(v)) & "\"", v) & other_args & (updater_var_ref_name(vs) : vs <- value_stores)
  //     );
  //   } : v, t <- ord_tables);

  //   foreign_keys = isort(block.insert_checked_foreign_keys & block.delete_checked_foreign_keys);
  //   foreign_key_checkers_init_code = ({
  //     var = foreign_key_checker_ref_name(k);
  //     type = native_foreign_key_checker_type(k, block.tables(k.origin), block.tables(k.target));
  //     origin = pending_updates_var_ref_name(k.origin);
  //     target = pending_updates_var_ref_name(k.target);
  //     return native_new_call(var, type, (origin, target));
  //   } : k <- foreign_keys);

  //   body = linked_updaters_init_code & dep_msg_vars_init_code & dep_apply_code_vars_init_code &
  //          init_vars_code & value_stores_init_code & tables_init_code & foreign_key_checkers_init_code;

  //   class_name = native_auxiliary_name(block.name);
  //   args = append((native_auxiliary_name(l) & " l" & _print_(i) : l @ i <- block.links), ", ");
  //   sgn = class_name & " " & updater_creation_proc_name(block.name) & "(" & args & ") {";
  //   return (sgn, "  " & class_name & " updater = new " & class_name & "();") &
  //          indent_lines(body) &
  //          ("  return updater;", "}");
  // }


  // String* auxiliary_reset_code(StaticBlock block) {
  //   var_ids = (bare_id(v) : v <- isort(keys(block.state_vars)));
  //   vars_reset_code = (native_var_ref_name(pending_state_var(id)) & " = make_blank_obj();" : id <- var_ids);

  //   dep_msg_vars_reset_code = (dependee_msg_var_ref_name(linked_db_var(i)) & " = null;" : i < |block.links|);
  //   dep_apply_code_vars_reset_code = (dependee_apply_code_var_ref_name(linked_db_var(i)) & " = 0;" : i < |block.links|);

  //   value_stores_reset_code = (
  //     native_call(native_value_store_method_prefix(block.value_stores(vs)) & "_aux_reset", (updater_var_ref_name(vs))) : vs, _ <- isort(block.value_stores)
  //   );

  //   tables_reset_code = ({
  //     prefix = match (t)
  //       mandatory_column()  = native_column_method_prefix(t.repr),
  //       _                   = native_table_method_prefix(t);
  //     return native_call(prefix & "_aux_reset", (pending_updates_var_ref_name(v)));
  //   } : v, t <- isort(block.tables));

  //   body = vars_reset_code & dep_msg_vars_reset_code & dep_apply_code_vars_reset_code &
  //          value_stores_reset_code & tables_reset_code;

  //   sgn = "void " & auxiliary_reset_proc_name(block.name) & "(" & native_auxiliary_name(block.name) & " " & db_auxiliary_arg_name & ") {";
  //   return (sgn) & indent_lines(body) & ("}");
  // }


  String* var_apply_code(Atom var_id) {
    psv_str = native_var_ref_name(pending_state_var(var_id));
    mv_str = native_var_ref_name(memb_var(var_id));
    pool_ref_str = "&" & auto_or_db_arg_name & "->mem_pool";
    return (
      "if (!is_blank(" & psv_str & "))",
      "  " & mv_str & " = copy_to_pool(" & pool_ref_str & ", " & psv_str & ");"
    );
  }


  String native_user_method_decl(DBSymbol block_name, MethodId method_id, OptCompMethod method) {
    args_str = append((native_var_type(a) & ", " : a <- method.args));
    return native_type(method.ret_val_repr) & " " & user_def_method_name(block_name, method_id) & "(" & target_arg_decl(block_name) & ", " & args_str & "ENV &env);";
  }

  String* native_user_def_method_code(DBSymbol block_name, MethodId method_id, OptCompMethod method) {
    args_str = append((native_var_type(a) & " " & native_var_decl_name(a) & ", " : a <- method.args));
    sgn = native_type(method.ret_val_repr) & " " & user_def_method_name(block_name, method_id) & "(" & target_arg_decl(block_name) & ", " & args_str & "ENV &env) {";
    vars_decls = gen_vars_decls(method.body, set(method.args));
    body_text = vars_decls & ("" if vars_decls != ()) & native_code(method.body, nothing, break_target = nothing);
    return (sgn) & indent_lines(body_text) & ("}");
  }


  // String* native_user_def_method_code(DBSymbol block_name, MethodId method_id, Maybe[StdVar]* args, Instr* body) {
  //   final_args = (if a != nothing then value(a) else fn_arg(i) : a @ i <- args);
  //   args_str = append(("OBJ " & native_var_decl_name(a) & ", " : a <- final_args));
  //   sgn = "OBJ " & user_def_method_name(block_name, method_id) & "(" & args_str & "ENV &env) {";
  //   vars_decls = gen_vars_decls(body, [value(a) : a <- args, a != nothing]);
  //   body_text = vars_decls & ("" if vars_decls != ()) & native_code(body, nothing, break_target = nothing);
  //   return (sgn) & indent_lines(body_text) & ("}");
  // }

  String *handler_methods_arrays(StaticBlock block) {
    num_msg_handlers = |block.handlers|;
    array_name = msg_handler_entry_point_array(block.name);
    rel_auto_type = native_name(block.name);
    rel_auto_aux_type = native_auxiliary_name(block.name);
    defs = ("", "bool (*" & array_name & "[" & _print_(num_msg_handlers) & "])(" & rel_auto_type & " *, " & rel_auto_aux_type & " *, OBJ, ENV &) = {");
    for i < num_msg_handlers {
      line = msg_handler_entry_point_name(block.name, handler_id(i));
      line = line & "," if i != num_msg_handlers - 1;
      defs = (defs | "  " & line);
    }
    defs = (defs | "};");
    return defs;
  }

  String* handler_resolution_code(StaticBlock block) {
    if block.handler_dispatch_resolver != nothing {
      arg, body = value(block.handler_dispatch_resolver);
      sgn = "uint32 " & handler_dispatch_resolver_name(block.name) & "(OBJ " & native_var_decl_name(arg) & ") {";
      return (sgn) & indent_lines(native_code(body, nothing, break_target = nothing)) & ("}");
    }
    else
      return ();
  }


  String** native_handlers_code(StaticBlock b) {
    sorted_handlers = _isort_([k : k _ <- b.handlers]);
    let block = b
      code = (native_handler_code(b.name, id, b.handlers(id).args_vars, b.handlers(id).body) : id <- sorted_handlers);
    return code;
  }
}


implicit prg_data : PrgData, rel_vars_perm_map : [DBSymbol -> [RelVar -> [+Nat -> Nat]]], context : <core>, block : StaticBlock, debug_mode : Bool {
  String* native_handler_code(DBSymbol block_name, HandlerId handler_id, <StdVar, FnArg>* args, Instr* body) {
    args_decls = (target_arg_decl(block_name), auxiliary_arg_decl(block_name)) & (obj_type_name & " " & native_var_decl_name(a) : a <- args) & ("ENV &env");
    args_str = append(("OBJ " & native_var_decl_name(a) & ", " : a <- args));
    sgn = "bool " & handler_name(block_name, handler_id) & "(" & append(args_decls, ", ") & ") {";
    vars_decls = gen_vars_decls(body, [a : a <- args, a :: StdVar]);
    body_text = vars_decls & ("" if vars_decls != ()) & native_code(body, nothing, break_target = nothing);
    body_text = body_text & run_and_check_dependees_and_check_code(handler_id);

    main_method = (sgn) & indent_lines(body_text) & ("}");
    apply_and_reset_methods = handler_apply_and_reset_methods(handler_id);
    entry_point_method = handler_entry_point_method(handler_id);

    return main_method & apply_and_reset_methods & entry_point_method;


    String* run_and_check_dependees_and_check_code(HandlerId handler_id) {
      dependees = [a -> linked_db_var_type(block, a) : a <- updated_dependees(handler_id, ?)];
      dependees_code = dependees_run_and_check_code(block.name, dependees);

      insertion_tables = [t : t <- table_vars_with_insertions(handler_id, ?)];
      deletion_tables = [t : t <- table_vars_with_deletions(handler_id, ?)];
      check_code = updates_check_code(block, insertion_tables, deletion_tables);

      return dependees_code & check_code;
    }


    String* handler_apply_and_reset_methods(HandlerId handler_id) {
      memb_vars = [v : v <- updated_memb_vars(handler_id, ?)];
      value_stores = [v : v <- value_stores_with_insertions(handler_id, ?)];
      dependees = [a : a <- updated_dependees(handler_id, ?)];
      insertion_tables = [t : t <- table_vars_with_insertions(handler_id, ?)];
      deletion_tables = [t : t <- table_vars_with_deletions(handler_id, ?)];
      table_vars = insertion_tables & deletion_tables;
      tables = [t -> block.tables(t) : t <- table_vars];

      dependees_code = dependees_apply_code([a -> linked_db_var_type(block, a) : a <- dependees]);

      apply_code = updates_apply_code(dependees, memb_vars, value_stores, tables);
      finish_code = updates_finish_code(deletion_tables, block);
      reset_code = updates_reset_code(memb_vars, value_stores, tables, dependees);

      args = (target_arg_decl(block.name), auxiliary_arg_decl(block.name));
      apply_sgn = "void " & native_apply_method_name(block.name, handler_id) & "(" & append(args, ", ") & ") {";
      body = dependees_code & apply_code & finish_code;
      apply_method_text = ("", apply_sgn) & indent_lines(body) & ("}");

      reset_sgn = "void " & native_reset_method_name(block.name, handler_id) & "(" & auxiliary_arg_decl(block.name) & ") {";
      reset_method_text = ("", reset_sgn) & indent_lines(reset_code) & ("}");

      return apply_method_text & reset_method_text;
    }


    String* handler_entry_point_method(HandlerId handler_id) {
      target_name = auto_or_db_arg_name;
      aux_name = db_auxiliary_arg_name;

      method_name = msg_handler_entry_point_name(block.name, handler_id);
      formal_args = (target_arg_decl(block.name), auxiliary_arg_decl(block.name), obj_type_name & " msg", env_arg_decl);

      run_and_check_method_name = native_name(block.name, handler_id);
      apply_method_name = native_apply_method_name(block.name, handler_id);
      reset_method_name = native_reset_method_name(block.name, handler_id);

      return (
        "",
        "bool " & method_name & "(" & append(formal_args, ", ") & ") {",
        "  try {",
        "    bool ok = " & run_and_check_method_name & "(" & target_name & ", " & aux_name & ", msg, " & env_arg_name & ");",
        "    if (ok)",
        "      " & apply_method_name & "(" & target_name & ", " & aux_name & ");",
        "    " & reset_method_name & "(" & aux_name & ");",
        "    return ok;",
        "  }",
        "  catch (...) {",
        "    " & reset_method_name & "(" & aux_name & ");",
        "    return false;",
        "  }",
        "}"
      );

      // main_handler_args = (target_name, aux_name, "msg", "env");
      // apply_method_args = (target_name, aux_name, "code");
      // body = (
      //   // "int depth = get_call_stack_depth();",
      //   "  switch_mem_stacks();",
      //   "",
      //   "try {",
      //   "  //## SET FLAG SIGNALLING WE'RE INSIDE A TRANSACTION",
      //   "  int code = " & update_name(block_name, main_handler) & "(" & append(main_handler_args, ", ") & ");",
      //   "  //## RESET TRANSACTION FLAG",
      //   "  " & native_apply_and_reset_method_name(block_name, main_handler) & "(" & append(apply_method_args, ", ") & ");",
      //   "  //## CLEAR THE ERROR MESSAGE",
      //   "  unswitch_mem_stacks();",
      //   "  clear_unused_mem();",
      //   "  return true;",
      //   "}",
      //   "catch (...) {",
      //   "  //## RESET TRANSACTION FLAG",
      //   "  //## " & auxiliary_reset_proc_name(block_name) & "(" & aux_name & ");",
      //   "  //## CLEAR THE ERROR MESSAGE",
      //   "  unswitch_mem_stacks();",
      //   "  clear_unused_mem();",
      //   "  return false;",
      //   "}"
      // );
      // formal_args = (target_arg_decl(block_name), auxiliary_arg_decl(block_name), obj_type_name & " msg", env_arg_decl);
      // sgn = "bool " & name & "(" & append(formal_args, ", ") & ") {";
      // return (sgn) & indent_lines(body) & ("}");

      // name = update_entry_point_name(block_name);


    }
  }


  String* updates_reset_code([MembVar] memb_vars, [ValueStoreId] value_stores, [TableVar -> AnyTable] tables, [LinkedDBVar] dependees) {
    memb_vars_code = (
      native_var_ref_name(pending_state_var(bare_id(v))) & " = make_blank_obj();"
      : v <- isort(memb_vars)
    );

    value_stores_code = (
      native_call(native_value_store_method_prefix(block.value_stores(vs)) & "_aux_reset", (updater_var_ref_name(vs)))
      : vs <- isort(value_stores)
    );

    tables_code = ({
      table = tables(v);
      prefix = match (table)
        mandatory_column()  = native_column_method_prefix(table.repr),
        _                   = native_table_method_prefix(table);
      return native_call(prefix & "_aux_reset", (pending_updates_var_ref_name(v)));
    } : v <- isort(keys(tables)));

    return append_with_sep((memb_vars_code, value_stores_code, tables_code));
  }


  String* updates_apply_code([LinkedDBVar] dependees, [MembVar] memb_vars, [ValueStoreId] value_stores_with_insertions, [TableVar -> AnyTable] tables) {
    code = join((var_apply_code(bare_id(v)) : v <- isort(memb_vars)));

    if value_stores_with_insertions != [] {
      value_stores_code = (
        native_call(native_value_store_method_prefix(block.value_stores(s)) & "_aux_apply", (s, updater_var_ref_name(s), :mem_pool))
        : s <- isort(value_stores_with_insertions)
      );
      code = (code | "") if code != ();
      code = code & value_stores_code;
    }

    if tables != [] {
      code = (code | "") if code != ();

      ord_tables = sort_by_key(keys(tables), arity(tables($)));
      for t <- ord_tables {
        table = tables(t);

        value_store_args = join(({
          prefix = native_value_store_method_prefix(block.value_stores(v));
          return (prefix & "_incr_rc", prefix & "_aux_decr_rc", v, updater_var_ref_name(v));
        } : v <- table_value_stores(table)));

        args = if is_mandatory_column(table)
          then (table.master, pending_updates_var_ref_name(table.master), t, pending_updates_var_ref_name(t), :mem_pool)
          else (table.master if is_slave_column(table), t, pending_updates_var_ref_name(t)) & value_store_args & (:mem_pool);

        ## THERE ARE ALL SORTS OF UNNECESSARY VALUE STORE ARGUMENTS HERE THAT SHOULD BE ELIMINATED
        args = match (table)
          table()             |
          master_bin_table()  |
          column()            = (t, pending_updates_var_ref_name(t)) & value_store_args,
          mandatory_column()  = (table.master, pending_updates_var_ref_name(table.master), t, pending_updates_var_ref_name(t)),
          slave_tern_table()  = (table.master, t, pending_updates_var_ref_name(t)) & value_store_args,
          slave_column()      = (t, pending_updates_var_ref_name(t));
        args = (args | :mem_pool);

        suffix = match (table)
          slave_column()  = "_aux_slave_apply",
          _               = "_aux_apply";
        method_name = native_table_method_prefix(tables(t)) & suffix;

        apply_instr = native_call(method_name, args);

        masters_raw_columns = prg_data.masters_raw_columns(block.name);
        if arity(table) == 1 and masters_raw_columns(t, _) {
          capacity_var = native_var_decl_name(t) & "_capacity";
          new_capacity_var = native_var_decl_name(t) & "_new_capacity";

          capacity_expr = native_call(native_table_method_prefix(table) & "_capacity", (native_var_ref_name(t)));

          resize_instrs = (
            native_call(native_table_method_prefix(block.tables(c)) & "_resize", (c, capacity_var, new_capacity_var, :mem_pool))
            : c <- isort([c : c <- masters_raw_columns(t, ?)])
          );

          code = code & (
            "uint32 " & capacity_var & " = " & capacity_expr & ";",
            apply_instr,
            "uint32 " & new_capacity_var & " = " & capacity_expr & ";",
            "if (" & capacity_var & " != " & new_capacity_var & ") {"
          ) & indent_lines(resize_instrs) & (
            "}"
          );
        }
        else
          code = (code | apply_instr);
      }
    }

    return code;
  }
}


implicit prg_data : PrgData, rel_vars_perm_map : [DBSymbol -> [RelVar -> [+Nat -> Nat]]], context : <core>, debug_mode : Bool {
  String* dependees_run_and_check_code(DBSymbol block_name, [LinkedDBVar -> DBSymbol] vars) {
    return (); //## IMPLEMENT IMPLEMENT IMPLEMENT

    // code = ();
    // for v <- isort(keys(vars)) {
    //   msg_var_name = dependee_msg_var_ref_name(v);
    //   args = (v, updater_var_ref_name(v), msg_var_name, "env");
    //   instr = native_call(dependee_apply_code_var_ref_name(v), native_name(vars(v), main_handler), args);
    //   code = (code | "if (!is_blank(" & msg_var_name & "))", "  " & instr);
    // }
    // return code;
  }


  String* dependees_apply_code([LinkedDBVar -> DBSymbol] vars) {
    return (); //## IMPLEMENT IMPLEMENT IMPLEMENT

    // code = ();
    // for v <- isort(keys(vars)) {
    //   msg_var_name = dependee_msg_var_ref_name(v);
    //   apply_code_var_name = dependee_apply_code_var_ref_name(v);
    //   args = (v, updater_var_ref_name(v), dependee_apply_code_var_ref_name(v));
    //   instr = native_call(native_apply_and_reset_method_name(vars(v), main_handler), args);
    //   code = (code |
    //     "if (!is_blank(" & msg_var_name & ")) {",
    //     "  " & instr,
    //     "  " & msg_var_name & " = make_blank_obj();",
    //     "  " & apply_code_var_name & " = -1;",
    //     "}"
    //   );
    // }
    // return code;
  }


  String* updates_finish_code([TableVar] deletion_tables, StaticBlock block) {
    value_stores_with_deletions = [s : v <- deletion_tables, s <- table_value_stores(block.tables(v))];
    code = (
      native_call(native_value_store_method_prefix(block.value_stores(v)) & "_aux_apply_deferred_releases", (v, updater_var_ref_name(v)))
      : v <- isort(value_stores_with_deletions)
    );
    return code;
  }


  String* updates_check_code(StaticBlock block, [TableVar] insertion_tables, [TableVar] deletion_tables) {
    mutated_tables = insertion_tables & deletion_tables;
    mutated_tables = sort_by_key(mutated_tables, arity(block.tables($)));

    keys = [(v, arity(t), k) : v t <- block.tables, insertion_tables(v), k <- keys(t)];
    keys = sort_by_key(keys, order);

    insert_checked_foreign_keys = [k : k <- block.insert_checked_foreign_keys, insertion_tables(k.origin)];
    insert_checked_foreign_keys = sort_by_key(insert_checked_foreign_keys, order);

    delete_checked_foreign_keys = [k : k <- block.delete_checked_foreign_keys, insertion_tables(k.origin)];
    delete_checked_foreign_keys = sort_by_key(delete_checked_foreign_keys, order);

    check_code = ("" if mutated_tables != ());

    for t <- mutated_tables
      check_code = check_code & aux_prepare_code(t, block);

    check_code = (check_code | "") if keys != () and not ends_with_empty_line(check_code);

    for v, a, k <- keys {
      fn_call = check_call(v, a, k, block);
      check_code = (check_code | "if (!" & fn_call & ")", " return false;");
    }

    check_code = (check_code | "") if insert_checked_foreign_keys != () and not ends_with_empty_line(check_code);

    for k <- insert_checked_foreign_keys {
      check_expr = foreign_key_forward_check_expr(k, block);
      check_code = (check_code | "if (!" & check_expr & ")", "  return false;");
    }

    check_code = (check_code | "") if delete_checked_foreign_keys != () and not ends_with_empty_line(check_code);

    for k <- delete_checked_foreign_keys {
      check_expr = foreign_key_backward_check_expr(k, block);
      check_code = (check_code | "if (!" & check_expr & ")", "  return false;");
    }

    check_code = (check_code | "", "return true;");

    return check_code;


    String* aux_prepare_code(TableVar var, StaticBlock block) {
      table_type = block.tables(var);
      needs_preparation = match (table_type)
        mandatory_column()  = false,
        _                   = true;
      return () if not needs_preparation;
      method_name = native_table_method_prefix(table_type) & "_aux_prepare";
      args = (pending_updates_var_ref_name(var));
      return (native_call(method_name, args));
    }


    String check_call(TableVar var, NzNat arity, [+Nat] key, StaticBlock block) {
      table_type = block.tables(var);
      method_name = match (table_type)
        table()             = table_key_check_method_names(arity, key, !),
        master_bin_table()  = undefined,
        slave_tern_table()  = slave_tern_table_key_check_method_names(key, !),
        mandatory_column()  = native_table_method_prefix(table_type) & "_aux_check_key_1",
        column()            = native_column_method_prefix(table_type.repr) & "_aux_check_key_1",
        slave_column()      = native_column_method_prefix(table_type.repr) & "_aux_check_key_1";
      aux_var = pending_updates_var_ref_name(var);
      args = match (table_type)
        column()            = (var, aux_var, :mem_pool),
        mandatory_column()  = (table_type.master, var, aux_var, :mem_pool),
        slave_tern_table()  = (table_type.master, var, pending_updates_var_ref_name(table_type.master) if key == [0, 1], aux_var),
        table()             = (var, aux_var, :mem_pool if arity == 2),
        master_bin_table()  = (var, aux_var),
        slave_column()      = (var, aux_var, :mem_pool);
      return native_call_expr(method_name, args);
    }


    String foreign_key_forward_check_expr(BlockForeignKey key, StaticBlock block) {
      method_name = foreign_key_forward_checker_name(key.type, block.tables(key.origin), block.tables(key.target));
      args = (key.origin, pending_updates_var_ref_name(key.origin), key.target, pending_updates_var_ref_name(key.target));
      return native_call_expr(method_name, args);
    }


    String foreign_key_backward_check_expr(BlockForeignKey key, StaticBlock block) {
      method_name = foreign_key_backward_checker_name(key.type, block.tables(key.origin), block.tables(key.target));
      needs_origin_ref = match (block.tables(key.target))
        table() t?  = arity(t) != 1 ,
        _           = true;
      args = (key.target if needs_origin_ref, pending_updates_var_ref_name(key.target), key.origin, pending_updates_var_ref_name(key.origin));
      return native_call_expr(method_name, args);
    }


    [NzNat, [+Nat], String] table_key_check_method_names = [
      2,  [0],    "bin_table_aux_check_key_1";
      2,  [1],    "bin_table_aux_check_key_2";
      3,  [2],    "tern_table_aux_check_key_3";
      3,  [0, 1], "tern_table_aux_check_key_12";
      3,  [1, 2], "tern_table_aux_check_key_23";
      3,  [0, 2], "tern_table_aux_check_key_13"
    ];


    [[+Nat] -> String] slave_tern_table_key_check_method_names = [
      [0, 1]  -> "slave_tern_table_aux_check_key_12",
      [2]     -> "slave_tern_table_aux_check_key_3"
    ];


    Nat order((TableVar, NzNat, [+Nat]) key) {
      _, arity, args = key;
      return key_check_orders(arity, args, !);
    }


    [NzNat, [+Nat], Nat] key_check_orders = [
      2,  [0],      0;
      3,  [0, 1],   0;
      2,  [1],      1;
      3,  [1, 2],   1;
      3,  [2],      2;
      3,  [0, 2],   2
    ];


    Nat order(BlockForeignKey key) =
      match (key.type)
        unary_unary             = 0,
        unary_binary(i?)        = i,
        unary_ternary(i?)       = i,

        binary_unary(i?)        = i,
        binary_ternary          = 0,

        ternary_unary(i?)       = i,
        ternary_binary          = 0,

        unary_sym_binary        = 0,
        sym_binary_unary        = 0,

        unary_sym_ternary_12    = 0,
        unary_sym_ternary_3     = 2,

        sym_ternary_unary_12    = 0,
        sym_ternary_unary_3     = 2,

        sym_binary_sym_ternary  = 0,
        sym_ternary_sym_binary  = 0;
  }
}


## THIS ONE PROBABLY BELONGS SOMEWHERE ELSE
ValueStoreId* table_value_stores(AnyTable table) =
  table()             = if table.symmetric then drop(table.value_stores, 1) else table.value_stores,
  master_bin_table()  |
  slave_tern_table()  = {assert not table.symmetric; return table.value_stores;},
  mandatory_column()  |
  column()            = (table.value_store),
  slave_column()      = table.value_stores;
