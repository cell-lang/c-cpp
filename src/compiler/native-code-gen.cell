implicit prg : CompiledPrg, rel_vars_perm_map : [DBSymbol -> [RelVar -> [+Nat -> Nat]]],
    generated : [BasicTypeSymbol], debug_mode : Bool {

  [String -> String*] generated_code(Bool include_runtime) {
    assert |program_symbols| <= 64 * 1024; ## IMPLEMENT PROPERLY

    has_main = (p <- prg.procs : p.name == proc_symbol(:main));
    has_static_autos = prg.static_blocks != [];

    return [
      "generated.cpp" -> flatten(generated_content(include_runtime)),
      "runtime.cpp"   -> flatten(runtime_content(has_static_autos)) if include_runtime,
      "typedefs.cpp"  -> flatten(data_exchange_types) if not has_main and data_exchange_types != (),
      "automata.cpp"  -> flatten(wrappers_content) if not has_main,
      "automata.txt" -> flatten(automata_docs) if not has_main
    ];


    Text runtime_content(Bool has_static_autos) = (
      ( "using System;",
        "using System.IO;",
        "using System.Text;",
        "using System.Collections.Generic;",
        "using System.Runtime.CompilerServices;",
        "",
        ""
      ),
      core_runtime,
      table_runtime if has_static_autos
    );


    Text generated_content(Bool include_runtime) = (
      ( "#include \"lib.h\"",
        "#include \"iolib.h\"",
        "",
        ""
      ) if not include_runtime,

      symbol_decls, "", "",
      symbol_table, "", "",
      int_seqs_decls, "", "",
      symb_seqs_decls, "", "",
      env_decl, "", "",
      abstract_closure_class_decl, "", "",
      native_opt_type_decls(context = :core), "", "",
      proc_defs, "", "",
      custom_parser, "", "",
      main_fn_if_req, "", ""
    );


    Text symbol_decls {
      let context = :core
        code = ("const uint16 " & symb_idx_name(s) & " = " & printed(i) & ";" : s @ i <- program_symbols);
      return code;
    }


    Text symbol_table {
      code = (
        "const char *map_symb_to_str[" & _print_(|program_symbols|) & "] = {",
        ("\"" & _print_(bare_obj(s)) & "\"," : s <- program_symbols),
        "};"
      );
      return code;
    }


    Text env_decl {
      all_impl_args = union([p.impl_args : p <- prg.procs]);
      semi_consts_cache_vars = isort([p.name : p <- prg.procs, p.cached and p.impl_args != []]);

      let context = :core
        env_decl = (
          "typedef struct {",
          ("OBJ " & native_var_decl_name(impl_arg(bare_id(a))) & ";" : a <- isort(all_impl_args)),
          ("" if all_impl_args != [] and semi_consts_cache_vars != ()),
          ("OBJ " & memo_var_name(v, context=:core) & ";" : v <- semi_consts_cache_vars),
          "} ENV;"
        );

      return env_decl;
    }


    Text abstract_closure_class_decl {
      arities = [p.arity : pd <- prg.procs, p <- pd.cls_args];
      return () if arities == [];

      return (
        "struct CLS {",
        ( "union {",
          ( "OBJ (*fn_ptr_" & printed(a) & ")(" & append(a * ("OBJ"), ", ") & ", const OBJ *, const CLS *, const void *, ENV &env);"
            : a @ i <- isort(arities)
          ),
          "};",
          "const OBJ  *capt_vars;",
          "const CLS  *capt_cls;",
          "const void *capt_auto;"
        ),
        "};"
      );
    }


    Text int_seqs_decls {
      return (("") & gen_int_seq_code(s, i) : s @ i <- prg.int_seqs);
    }


    Text symb_seqs_decls {
      return symbols_arrays_decls(values(symbols_sets_info));
    }


    Text proc_defs = native_code(
      isort(prg.procs),
      isort(prg.bool_procs),
      sorted_lambda_exprs,
      ord_react_blocks,
      ord_static_blocks,
      prg.int_seqs,
      context = :core
    );


    Text main_fn_if_req {
      has_main = (p <- prg.procs : p.name == proc_symbol(:main));
      return if has_main then main_fn(debug_mode) else ();
    }

    ////////////////////////////////////////////////////////////////////////////

    // Generated interface type declarations
    Text data_exchange_types {
      decls = gen_inter_types_decls(typedefs = prg.typedefs);
      return () if decls == ();
      return (
        "namespace Cell.Typedefs {",
        decls,
        "}"
      );
    }

    Text wrappers_content {
      content = (
        "#pragma warning disable 162, 164, 168, 169, 219",
        "",
        "namespace Cell.Automata {"
      );

      if rel_auto_wrappers != ()
        content = (content | ("// Facades for relational automata", "", rel_auto_wrappers));

      if react_auto_wrappers != ()
        content = (content | "// Facades for reactive automata", "", react_auto_wrappers);

      content = (content | "}");

      let typedefs = prg.typedefs {
        types_decls, hierarchy = inter_types_decls;
        if types_decls != [] {
          conv_fns = decl_types_export_functs(types_decls, hierarchy);
          content = (
            content |
            "",
            "",
            "namespace Cell.Generated {",
            ( "// Conversion functions for declared interface types",
              "public static class Convert {",
              conv_fns,
              "}"
            ),
            "}"
          );
        }
      }

      return content;
    }


    Text react_auto_wrappers {
      let typedefs = prg.typedefs
        react_auto_wrappers = (react_auto_wrapper(b) : b <- ord_react_blocks);
      return (code : _, code, _ <- react_auto_wrappers);
    }


    Text rel_auto_wrappers {
      let typedefs = prg.typedefs {
        react_auto_wrappers = (react_auto_wrapper(b) : b <- ord_react_blocks);
        rel_auto_wrappers = (static_auto_wrapper(b) : b <- ord_static_blocks);
      }
      return (code : _, code, _ <- rel_auto_wrappers);
    }

    ////////////////////////////////////////////////////////////////////////////

    Text automata_docs {
      docs = ();

      let typedefs = prg.typedefs
        all_docs = (static_auto_wrapper(b)(2) : b <- ord_static_blocks);
      rel_auto_docs = insert_seps(all_docs, (""));

      if rel_auto_docs != () {
        docs = (docs | "// Facades for relational automata", "");
        docs = docs & rel_auto_docs;
      }

      let typedefs = prg.typedefs
        react_auto_docs = (react_auto_wrapper(b)(2) : b <- ord_react_blocks);

      if react_auto_docs != () {
        docs = (docs | "") if docs != ();
        docs = (docs | "// Facades for reactive automata", "");
        docs = docs & react_auto_docs;
      }

      return docs;
    }
  }
}


implicit prg : CompiledPrg {
  StaticBlock* ord_static_blocks {
    // Static blocks sorted in topological order
    static_blocks_dep_map = [b.name -> set(b.links) : b <- prg.static_blocks];
    ord_static_block_names = join((isort(bs) : bs <- topological_sort(static_blocks_dep_map)));
    static_blocks_by_name = [b.name -> b : b <- prg.static_blocks];
    return (static_blocks_by_name(b, !) : b <- ord_static_block_names);
  }

  ReactBlock* ord_react_blocks {
    // Reactive blocks sorted in topological order
    react_blocks_dep_map = [b.name -> [t : _ t <- b.nested_auto_vars] : b <- prg.react_blocks];
    ord_react_blocks_names = join((isort(bs) : bs <- topological_sort(react_blocks_dep_map)));
    react_blocks_by_name = [b.name -> b : b <- prg.react_blocks];
    return (react_blocks_by_name(b, !) : b <- ord_react_blocks_names);
  }
}


String* private_class_def(String* class_def) = (
    if take(l, 8) == "package " or take(l, 7) == "import "
      then ""
    else if take(l, 16) == "public interface"
      then drop(l, 7)
    else if take(l, 12) == "public class"
      then drop(l, 7)
    else l
  : l <- class_def
);


String native_int_type(Int min_val, Int max_val) {
  for lb, up, type_name <- type_bounds
    return type_name if min_val >= lb and max_val < up;
  return "long";


  (Int, Int, String)+ type_bounds = (
    (0,             pow(2, 8),    "uint8"),
    (-pow(2, 7),    pow(2, 7),    "int8"),
    (0,             pow(2, 16),   "uint16"),
    (-pow(2, 15),   pow(2, 15),   "int16"),
    (0,             pow(2, 32),   "uint32"),
    (-pow(2, 31),   pow(2, 31),   "int32")
  );
}


String* gen_int_seq_code(Int+ int_seq, Nat seq_id) {
  min_elem = min(int_seq);
  max_elem = max(int_seq);

  type_name = native_int_type(min_elem, max_elem);

  sgn = type_name & " " & const_int_seq_name(seq_id) & "[" & _print_(|int_seq|) & "] = {";

  strs = (printed(n) : n <- int_seq);
  total_len = sum((length(s) : s <- strs)) + 2 * |strs|;

  if total_len < 60 {
    code = (sgn & append(strs, ", ") & "};");
  }
  else {
    max_len = nat(max((length(printed(n)) : n <- (min_elem, max_elem))));
    last_idx = |int_seq| - 1;
    strs = (align_text(s, max_len, ascii_space) & if i != last_idx then ", " else "" : s @ i <- strs);
    cont_lines = ("    " & append(ss) : ss <- split_into_groups(strs, nz_nat(100 / (max_len + 2))));
    code = (sgn) & cont_lines & ("  };");
  }

  return code;


  T+* split_into_groups(T+ items, NzNat max_group_size) {
    len = |items|;
    num_of_comp_groups = len / max_group_size;
    comp_groups_total_size = num_of_comp_groups * max_group_size;
    last_group_size = len - comp_groups_total_size;
    groups = (nonempty(subseq(items, i * max_group_size, max_group_size)) : i < num_of_comp_groups);
    groups = (groups | nonempty(subseq(items, comp_groups_total_size, last_group_size))) if last_group_size > 0;
    return groups;
  }


  String align_text(String str, Nat len, Nat filler) {
    str_len = length(str);
    filling = if len >= str_len then string(nat(len-str_len) * (filler)) else "";
    return filling & str;
  }
}


String* symbols_arrays_decls([(Symbol+, Nat)] symbs_seqs) {
  ord_symbs_seqs = sort_set(symbs_seqs, right($a) < right($b));
  return (symbols_array_decl(ss, i) : ss, i <- ord_symbs_seqs);

  String symbols_array_decl(Symbol+ symbs, Nat index) {
    name = const_symb_seq_name(index);
    let context = :core
      symbs_strs = (symb_idx_name(s) : s <- symbs);
    return "uint16 " & name & "[" & _print_(|symbs|) & "] = {" & append(symbs_strs, ", ") & "};";
  }
}


implicit context : NativeContext {
  String* gen_vars_decls(Instr* body, [AnyVar] exclusions) {
    vars_to_decl = [v : v <- vars_to_declare(body), not exclusions(v), not v :: AuxVar];

    vector_vars = [v : v <- vars_to_decl, v :: VecVar];
    array_vars = [v : v <- vars_to_decl, v :: ArrayVar];
    scalar_vars = vars_to_decl - vector_vars - array_vars;

    scalar_vars_by_type = group_by(scalar_vars, native_var_type);
    scalar_vars_decls = (
      t & " " & append((native_var_decl_name(v) : v <- isort(vs)), ", ") & ";"
      : t, vs <- isort(scalar_vars_by_type)
    );

    array_vars_by_type = group_by(array_vars, native_type($.repr));
    array_vars_decls = (
      t & " " & append(("*" & native_var_decl_name(v) : v <- isort(vs)), ", ") & ";"
      : t, vs <- isort(array_vars_by_type)
    );

    vec_vars_by_id = group_by(vector_vars, $.id);
    new_vec_vars = [vvar(id, nz_nat(max([v.size : v <- vs]))) : id vs <- vec_vars_by_id];
    vec_vars_decls = (var_decl(v) : v <- isort(new_vec_vars));

    opt_tag_rec_vars = isort([v : v <- scalar_vars, v :: OptTagRecVar]);
    ptr_vars_decls = (native_ptr_type(v) & " *" & native_ptr_var_name(v) & ";" : v <- opt_tag_rec_vars);

    assert {
      vec_var_ids  = [v.id : v <- vector_vars];
      ref_new_vec_vars = [vvar(id, nz_nat(max(nonempty([v.size : v <- vector_vars, v.id == id])))) : id <- vec_var_ids];
      return new_vec_vars == ref_new_vec_vars;
    };

    return scalar_vars_decls & ptr_vars_decls & array_vars_decls & vec_vars_decls;
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit prg : CompiledPrg, rel_vars_perm_map : [DBSymbol -> [RelVar -> [+Nat -> Nat]]], context : <core>, debug_mode : Bool {
  String* native_code(ObjProcDef* obj_proc_defs, BoolProcDef* bool_proc_defs, LambdaExpr* lambda_exprs, ReactBlock* react_blocks, StaticBlock* static_blocks, Int+* int_seqs) {
    type_checking_fns_decls = join((native_code(d, true) : d <- bool_proc_defs)) & 4 * ("");
    type_checking_fns = join((native_code(d, false) & ("", "") : d <- bool_proc_defs)) & 4 * ("");
    cls_decls = join((gen_lambda(d, i, true) : d @ i <- lambda_exprs)) & 4 * ("");
    closures = join((gen_lambda(d, i, false) & ("", "") : d @ i <- lambda_exprs)) & 4 * ("");
    fns_decls = join((native_code(d, true) : d <- obj_proc_defs)) & 4 * ("");
    functions = join((native_code(d, false) & ("", "") : d <- obj_proc_defs));

    static_blocks_code = join((("", "") & native_static_block_decl(b) : b <- static_blocks));
    react_blocks_code = join((("", "") & native_react_block_decl(b) : b <- react_blocks));

    return join((
      type_checking_fns_decls,
      cls_decls,
      fns_decls,
      type_checking_fns,
      closures,
      functions,
      static_blocks_code,
      react_blocks_code
    ));
  }


  String* native_code(ProcDef pd, Bool decl_only) {
    cached = pd.cached? and pd.cached;

    fn_name = native_fn_name(pd.name);

    suffix = if cached and not decl_only then "_calculate" else "";

    args_list = gen_args_list(pd);
    args_list_str = append(args_list, ", ");

    signature = ret_type_str(pd) & " " & fn_name & suffix & "(" & args_list_str & ")";

    return (signature & ";") if decl_only;

    body = pd.body;
    auto_vars_types = if pd.loc_auto_vars? then pd.loc_auto_vars else [];
    db_vars_types = if pd.loc_db_vars? then pd.loc_db_vars else [];

    var_decls = gen_vars_decls(body, if pd.args? then set(pd.args) else []);

    auto_vars = isort(keys(auto_vars_types));
    auto_var_decls = (native_name(auto_vars_types[v]) & " " & native_var_decl_name(v) & ";" : v <- auto_vars);

    db_vars_decls = (native_name(t) & " " & native_var_decl_name(v) & ";" : v, t <- isort(db_vars_types));
    aux_db_vars_decls = (native_updater_name(t) & " " & updater_var_decl_name(v) & ";" : v, t <- isort(db_vars_types));

    comp_body = native_code(body, nothing);

    has_var_decls = var_decls != () or auto_var_decls != () or db_vars_decls != ();
    code = (visibility(pd) & signature & " {",) & indent_lines(var_decls) & indent_lines(auto_var_decls) &
           indent_lines(db_vars_decls) & indent_lines(aux_db_vars_decls) &
           ("" if has_var_decls) & indent_lines(comp_body) & ("}");

    if cached {
      is_real_const = pd.cached? and pd.impl_args == [];
      cache_var_name = if is_real_const then fn_name & "__CV" else "env." & memo_var_name(pd.name);
      needs_set_flag = is_real_const and pd.ret_val_repr? and not is_nullable(pd.ret_val_repr);
      set_flag_name = if needs_set_flag then fn_name & "__CI" else "???"; ## UGLY UGLY UGLY
      ret_type_name = ret_type_str(pd);
      cast = if ret_type_name != "OBJ" then " (" & ret_type_name & ")" else "";

      wrapper_code = (
        "",
        "",
        "static " & ret_type_name & " " & cache_var_name & ";" if is_real_const,
        "static bool " & set_flag_name & ";" if needs_set_flag,
        "" if is_real_const,
        visibility(pd) & "static " & ret_type_name & " " & fn_name & "(" & args_list_str & ") {",
        "  if (" & cache_var_name & " == null)" if not needs_set_flag,
        "  if (!" & set_flag_name & ") {" if needs_set_flag,
        "    " & cache_var_name & " = " & fn_name & suffix & "(env);",
        "    " & set_flag_name & " = true;" if needs_set_flag,
        "  }" if needs_set_flag,
        "  return" & cast & " " & cache_var_name & ";",
        "}"
      );
      code = code & wrapper_code;
    }

    return code;


    Nat arity(ProcDef pd) =
      obj_proc_def()    = in_arity(pd),
      bool_proc_def()   = pd.arity;

    String ret_type_str(ProcDef proc_def) =
      obj_proc_def()    = native_type(proc_def.ret_val_repr),
      bool_proc_def()   = "bool";

    String visibility(ProcDef pd) = "";
      // bool_proc_def()   = "public ",
      // obj_proc_def()    = if pd.name :: ConvFnId then "public " else "";

    String* gen_args_list(ObjProcDef pd) {
      args = (native_var_type(v) & " " & native_var_decl_name(v) : v <- pd.args);
      cls_args = ("const CLS &" & native_var_decl_name(a.var) : a <- pd.cls_args);
      rel_auto_args = join((
        ( native_name(a.type) & " " & native_var_decl_name(a.var),
          native_updater_name(a.type) & " " & updater_var_decl_name(a.var)
        ) : a <- pd.rel_auto_args
      ));
      react_auto_args = (native_name(a.type) & " " & native_var_decl_name(a.var) : a <- pd.react_auto_args);
      args_list = args & cls_args & rel_auto_args & react_auto_args;
      args_list = (args_list | "ENV env") if not pd.name :: ConvFnId;
      return args_list;
    }

    String* gen_args_list(BoolProcDef pd) = ("OBJ " & native_var_decl_name(fn_arg(n)) : n < arity(pd));
  }


  String* gen_lambda(LambdaExpr lambda, Nat id, Bool decl_only) {
    body = remove_dead_code(lambda.cls.body); ## BAD BAD BAD: THIS OUGHT TO BE DONE IN DEAD CODE REMOVAL, NOT HERE
    vars_decls = gen_vars_decls(body, []);
    comp_body = native_code(body, nothing);
    full_body = vars_decls & ("" if vars_decls != ()) & comp_body;

    std_args  = ("OBJ " & native_var_decl_name(fn_arg(n)) : n < lambda.cls.arity);
    extra_args = ("const OBJ *capt_vars", "const CLS *capt_cls", "const void *capt_auto", "ENV &env"); ## BAD
    signature = "OBJ lambda_" & printed(id) & "(" & append(std_args & extra_args, ", ") & ")";

    return (signature & ";") if decl_only;

    return ({signature & " {"}) & indent_lines(full_body) & ("}");
  }
}

////////////////////////////////////////////////////////////////////////////////

type NonStringEncodable = blank_obj, ObjExpr, ElemVar, PendingInputVar, VecVar, ArrayVar, BoolExpr,
                          IntExpr, Int32Expr, FloatExpr, ItVar, StreamVar, AnyClsVar, AnyTableVar,
                          AnyValueStoreId, AnyAutoVar, AnyDBVar;

type Encodable = NonStringEncodable, String;


implicit context : NativeContext {
  String native_code(NonStringEncodable enc) = native_expr(enc);
  String native_code(String str) = str;


  String native_call_expr(String method_name, Encodable* args) =
    method_name & "(" & append((native_code(a) : a <- args), ", ") & ")";

  String native_method_call_expr(Encodable target, String method_name, Encodable* args) =
    native_code(target) & "." & method_name & "(" & append((native_code(a) : a <- args), ", ") & ")";

  String native_method_call(Encodable target, String method_name, Encodable* args) =
    native_method_call_expr(target, method_name, args) & ";";

  String native_method_call(Encodable res, Encodable target, String method_name, Encodable* args) =
    native_code(res) & " = " & native_method_call(target, method_name, args);

  String native_call(String static_name, Encodable* args) =
    static_name & "(" & append((native_code(a) : a <- args), ", ") & ");";

  String native_call(Encodable res, String static_name, Encodable* args) =
    native_code(res) & " = " & native_call(static_name, args);

  String native_new_call(Encodable res, String obj_type, Encodable* args) =
    native_code(res) & " = new " & obj_type & "(" & append((native_code(a) : a <- args), ", ") & ");";

  String native_assignment_code(Encodable var, Encodable value) =
    native_code(var) & " = " & native_code(value) & ";";
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

String* custom_parser = ();

// String* custom_parser = (
//   "",
//   "",
//   "public sealed class Parser : Cell.Runtime.Parser {",
//   "  public Parser(TokenStream tokens) : base(tokens) {",
//   "",
//   "  }",
//   "",
//   " protected override OBJ CreateTaggedObj(ushort tagId, OBJ obj) {",
//   "    return ConvertGenericTaggedValue(SymbObj.Get(tagId), obj);",
//   "  }",
//   "}",
//   "",
//   "",
//   "public static OBJ Parse(OBJ text) {",
//   "  return Parse(new System.IO.StringReader(text.GetString()));",
//   "}",
//   "",
//   "",
//   "public static OBJ Parse(System.IO.TextReader reader) {",
//   "  try {",
//   "    TokenStream tokens = new Tokenizer(new CharStream(reader));",
//   "    Parser parser = new Parser(tokens);",
//   "    OBJ obj = parser.ParseObj();",
//   "    parser.CheckEof();",
//   "    return Builder.CreateTaggedObj(SymbObj.SuccessSymbId, obj);",
//   "  }",
//   "  catch (Cell.Runtime.ParsingException e) {",
//   "    return Builder.CreateTaggedObj(SymbObj.FailureSymbId, Builder.CreateSeq(new int[] {e.line, e.col}));",
//   "  }",
//   "}"
// );


// String* main_method(Bool debug_mode) = (
//   "",
//   "",
//   "public static int Main(string[] args) {",
//   "  OBJ[] cellArgs = new OBJ[args.Length];",
//   "  for (int i=0 ; i < args.Length ; i++)",
//   "    cellArgs[i] = Miscellanea.StrToObj(args[i]);",
//   "  ENV env;",
//   "  Debug.debugMode = true;" if debug_mode,
//   "  OBJ res = Main_P(Builder.CreateSeq(cellArgs), env);",
//   "  Debug.OnProcessEnd();",
//   "  return res.IsInt() ? (int) res.GetLong() : 0;",
//   "}"
// );

String* main_fn(Bool debug_mode) = (
  // "",
  // "#include <stdio.h>",
  "",
  "",
  "int main(int argc, char **argv) {",
  "  OBJ args = make_empty_seq();",
  "  if (argc > 1) {",
  "    OBJ *arg_buff = new OBJ[argc-1];",
  "    for (int i=0 ; i < argc-1 ; i++)",
  "      arg_buff[i] = str_to_obj(argv[i+1]);",
  "    args = build_seq(arg_buff, argc-1);",
  "  }",
  "",
  "  ENV env;",
  "  memset(&env, 0, sizeof(ENV));",
  "",
  "  OBJ res = Main_P(args, env);",
  "",
  // "  release(args);",
  // "  release(res);",
  // "",
  // "  release_all_cached_objs();",
  // "",
  // "#ifndef NDEBUG",
  // "  if (get_live_objs_count() != 0) {",
  // "    fprintf(stderr, \"\\nMEMORY LEAK DETECTED!\\n\");",
  // "",
  // "    fprintf(stderr, \"\\nNumber of live objects: %d\\n\", get_live_objs_count());",
  // "    fprintf(stderr, \"Max number of live objects: %d\\n\", get_max_live_objs_count());",
  // "    fprintf(stderr, \"Total number of allocated objects: %d\\n\", get_total_objs_count());",
  // "",
  // "    // fprintf(stderr, \"\\nLive memory usage: %d\\n\", get_live_mem_usage());",
  // "    // fprintf(stderr, \"Max live memory usage: %d\\n\", get_max_live_mem_usage());",
  // "    // fprintf(stderr, \"Total memory requested: %d\\n\", get_total_mem_requested());",
  // "",
  // "    // print_all_live_objs();",
  // "  }",
  // "#endif",
  // "",
  "  return is_int(res) ? get_int_val(res) : 0;",
  "}"
);
