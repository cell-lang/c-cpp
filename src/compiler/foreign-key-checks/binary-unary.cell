implicit
  block                   : StaticBlock,
  table_var_aux_vars_map  : [TableVar -> (OptAuxTableVar+, Maybe[LocBoolVar])],
  effects_info            : EffectsInfo,
  prg_data                : PrgData,
  rel_vars_perm_map       : [DBSymbol -> [RelVar -> [+Nat -> Nat]]],
  context                 : <core>,
  debug_mode              : Bool,
  skip_integrity_checks   : Bool
{
  Maybe[Instr*] binary_unary_foreign_key_check_code(Nat origin_col_idx, TableVar origin, TableVar target, AnyTable origin_type, AnyTable target_type, Bool insertion_checked, Bool deletion_checked) {
    tables = effects_info.tables;

    if tables(target, _) {
      target_instr_id, target_action = only_pair(tables(target));
      if is_deletion(target_action) {
        if deletion_checked {
          check_expr = binary_unary_foreign_key_target_deletion_check_expr(origin_col_idx, origin, target, origin_type, target_type);
          return just((do_if(check_expr, ret_val(false))));
        }
        else {
          fail;
        }
      }
    }

    if tables(origin, _) {
      origin_instr_id, origin_action = only_pair(tables(origin));
      if origin_action == :insertion {
        if insertion_checked {
          check_expr = binary_unary_foreign_key_origin_insertion_check_expr(origin_col_idx, origin, target, origin_type, target_type);
          return just((do_if(check_expr, ret_val(false))));
        }
      }
      else if origin_action == :update {
        check_expr = binary_unary_foreign_key_origin_update_check_expr(origin_col_idx, origin, target, origin_type, target_type);
        return just((do_if(check_expr, ret_val(false))));
      }
    }

    return just(());
  }


  BoolExpr binary_unary_foreign_key_origin_update_check_expr(Nat origin_col_idx, TableVar origin, TableVar target, AnyTable origin_type, AnyTable target_type) {
    return binary_unary_foreign_key_origin_insertion_check_expr(origin_col_idx, origin, target, origin_type, target_type);
  }


  BoolExpr binary_unary_foreign_key_origin_insertion_check_expr(Nat origin_col_idx, TableVar origin, TableVar target, AnyTable origin_type, AnyTable target_type) {
    origin_aux_vars, maybe_origin_status_var = table_var_aux_vars_map(origin);

    origin_aux_var = cast_int32_var(origin_aux_vars(origin_col_idx));
    check_expr = neg(table_contains(target, target_type, (just(origin_aux_var))));

    if table_var_aux_vars_map(target, _) {
      target_instr_id, target_effect_info = only_pair(effects_info.tables(target));
      target_aux_vars, maybe_target_status_var = table_var_aux_vars_map(target);
      target_aux_var = cast_int32_var(only_unsafe(target_aux_vars));

      if target_effect_info == :insertion {
        extra_check_expr = neg(are_eq(origin_aux_var, target_aux_var));
      }
      else if target_effect_info == :update {
        fail;
      }
      else
        fail; // This case is already handled by the other function

      if maybe_target_status_var != nothing {
        target_status_var = value(maybe_target_status_var);
        extra_check_expr = or_else(neg(target_status_var), extra_check_expr);
      }

      check_expr = and(check_expr, extra_check_expr);
    }

    return check_expr;
  }


  BoolExpr binary_unary_foreign_key_target_deletion_check_expr(Nat origin_col_idx, TableVar origin, TableVar target, AnyTable origin_type, AnyTable target_type) {
    target_del_args, maybe_target_status_var = table_var_aux_vars_map(target);
    target_del_arg = cast_opt_loc_int32_var(only_unsafe(target_del_args));

    args = (if i == origin_col_idx and target_del_arg != :none then just(target_del_arg) else nothing : i < 2);
    check_expr = table_contains(origin, origin_type, args);

    if effects_info.tables(origin, _) {
      instr_id, action = only_pair(effects_info.tables(origin));
      origin_aux_vars, maybe_origin_status_var = table_var_aux_vars_map(origin);
      assert |origin_aux_vars| == 2;

      if action == :insertion or action == :update {
        if target_del_arg != :none {
          // insert origin(x, y); delete target(x')
          // origin(x, _) -> target(x) | origin(_, y) -> target(y)
          origin_aux_var = cast_int32_var(origin_aux_vars(origin_col_idx));
          extra_check_expr = are_eq(origin_aux_var, target_del_arg);
        }
        else
          extra_check_expr = true;

        if action == :update {
          if target_del_arg != :none {
            // insert origin(x, y); delete target(x')
            // origin(x, _) -> target(x) | origin(_, y) -> target(y)
            origin_aux_var = cast_int32_var(origin_aux_vars(origin_col_idx));
            extra_check_expr = are_eq(origin_aux_var, target_del_arg);
          }
          else
            extra_check_expr = true;

          origin_other_col_idx = if origin_col_idx == 0 then 1 else 0;
          if keys(origin_type)([origin_other_col_idx]) {
            // This is for counting the total number of foreign-key constrained values that are present and need to be deleted
            total_count_args = (
                if i != origin_col_idx
                  then just(cast_int32_var(origin_aux_vars(i)))
                  else if target_del_arg != :none then just(target_del_arg) else nothing
              : i < 2
            );
            // This is for counting the number of foreign-key contrained values that are actually deleted
            delete_count_args = (if i == origin_col_idx then a else nothing : a @ i <- total_count_args);
            deletion_check_expr = are_eq(
              get_count(origin, origin_type, delete_count_args),
              get_count(origin, origin_type, total_count_args)
            );
            check_expr = and_then(check_expr, neg(deletion_check_expr));
          }
        }

        if maybe_origin_status_var != nothing {
          origin_status_var = value(maybe_origin_status_var);
          extra_check_expr = and_then(origin_status_var, extra_check_expr);
        }

        check_expr = or_else(check_expr, extra_check_expr);
      }
      else {
        // origin_del_args = match (action) deletion(as?) = as;
        if target_del_arg != :none {
          checked_origin_del_arg = cast_opt_loc_int32_var(origin_aux_vars(origin_col_idx));
          unchecked_origin_del_arg = cast_opt_loc_int32_var(origin_aux_vars(if origin_col_idx == 0 then 1 else 0));

          if checked_origin_del_arg != :none {
            if unchecked_origin_del_arg != :none {
              // delete origin(x, y), delete target(x') : origin(x, _) -> target(x)
              // delete origin(x, y), delete target(y') : origin(_, y) -> target(y)

              args = (maybe(checked_origin_del_arg, i == origin_col_idx) : i < 2);
              get_count_expr = get_count(origin, origin_type, args);

              extra_check_expr = neg(are_eq(get_count_expr, 1));
            }
            else {
              // delete origin(x, *), delete target(x') : origin(x, _) -> target(x)
              // delete origin(*, y), delete target(y') : origin(_, y) -> target(y)

              extra_check_expr = are_eq(checked_origin_del_arg, target_del_arg);
            }
          }
          else {
            if unchecked_origin_del_arg != :none {
              // delete origin(*, y), delete target(x') : origin(x, _) -> target(x);
              // delete origin(x, *), delete target(y') : origin(_, y) -> target(y);

              // |origin(x', y)| == |origin(x', *)|
              // |origin(x, y')| == |origin(*, y')|
              args1 = (just(if i == origin_col_idx then target_del_arg else unchecked_origin_del_arg) : i < 2);
              args2 = (maybe(target_del_arg, i == origin_col_idx) : i < 2);
              count_expr_1 = get_count(origin, origin_type, args1);
              count_expr_2 = get_count(origin, origin_type, args2);
              extra_check_expr = neg(are_eq(count_expr_1, count_expr_2));
            }
            else {
              // delete origin(*, *), delete target(x') : origin(x, _) -> target(x);
              // delete origin(*, *), delete target(y') : origin(_, y) -> target(y);

              extra_check_expr = false;
            }
          }
        }
        else {
          // delete origin(_, _), delete target(*) : origin(x, _)

          args = (if a != :none then just(cast_loc_int32_var(a)) else nothing : a <- origin_aux_vars);
          extra_check_expr = are_eq(
            get_count(origin, origin_type, args),
            get_count(origin, origin_type, (nothing, nothing))
          );
        }

        if maybe_origin_status_var != nothing {
          origin_status_var = value(maybe_origin_status_var);
          extra_check_expr = and_then(origin_status_var, extra_check_expr);
        }

        check_expr = and_then(check_expr, extra_check_expr);
      }
    }

    if maybe_target_status_var != nothing {
      target_status_var = value(maybe_target_status_var);
      check_expr = and_then(target_status_var, check_expr);
    }

    return check_expr;
  }

  //////////////////////////////////////////////////////////////////////////////

  Int32Expr bin_table_aux_count(TableVar table_var, Table table, Maybe[Int32Var]+ match_args, TableAction action, OptAuxTableVar+ action_args) {
    assert |match_args| == 2 and |action_args| == 2;

    base_count_expr = get_count(table_var, table, match_args);
    delta_count_expr = match (action)
      insertion   = bin_table_insertion_delta_count(table_var, table, match_args, cast_loc_int32_vars(action_args)),
      update      = bin_table_update_delta_count(table_var, table, match_args, cast_loc_int32_vars(action_args)),
      deletion(_) = bin_table_deletion_delta_count(table_var, table, match_args, cast_opt_loc_int32_vars(action_args));
    return add32(base_count_expr, delta_count_expr);

  }


  Int32Expr bin_table_insertion_delta_count(TableVar table_var, Table table, Maybe[Int32Var]+ match_args, LocInt32Var+ insertion_args) {
    ins_match_expr = true;
    for match_arg @ i <- match_args
      if match_arg != nothing {
        arg_match_expr = are_eq(value(match_arg), insertion_args(i));
        ins_match_expr = and_then(ins_match_expr, arg_match_expr);
      }
    return bool_to_bit(ins_match_expr);
  }


  Int32Expr bin_table_deletion_delta_count(TableVar table_var, Table table, Maybe[Int32Var]+ match_args, OptLocInt32Var+ deletion_args) {
    count_args = (if del_arg != :none then just(del_arg) else match_args(i) : del_arg @ i <- deletion_args);
    count_expr = get_count(table_var, table, count_args);

    conds = ();
    for del_arg @ i <- deletion_args {
      match_arg = match_args(i);
      if del_arg != :none and match_arg != nothing
        conds = (conds | are_eq(del_arg, value(match_arg)));
    }
    if conds != ()
      count_expr = or_0_32(and_then(conds), count_expr);

    return minus32(count_expr);
  }


  Int32Expr bin_table_update_delta_count(TableVar table_var, Table table, Maybe[Int32Var]+ match_args, LocInt32Var+ insertion_args) {
    keys = table.keys;

    if keys == []
      return bin_table_insertion_delta_count(table_var, table, match_args, insertion_args);

    assert keys == [[0]] or keys == [[0], [1]];

    if keys == [[0]] {
      del_args = (insertion_args(0), :none);
      del_count_expr = bin_table_deletion_delta_count(table_var, table, match_args, del_args);
    }
    else {
      assert keys == [[0], [1]];

      del_count_expr_1 = bin_table_deletion_delta_count(table_var, table, match_args, (insertion_args(0), :none));
      del_count_expr_2 = bin_table_deletion_delta_count(table_var, table, match_args, (:none, insertion_args(1)));
      del_count_expr_12 = bin_table_deletion_delta_count(table_var, table, match_args, insertion_args);

      del_count_expr = add32(add32(del_count_expr_1, del_count_expr_2), minus32(del_count_expr_12));
    }

    ins_match_conds = ();
    for ins_arg @ i <- insertion_args {
      match_arg = match_args(i);
      if match_arg != nothing
        ins_match_conds = (ins_match_conds | are_eq(ins_arg, value(match_arg)));
    }
    ins_count_expr = if ins_match_conds != ()
      then bool_to_bit(and_then(ins_match_conds))
      else 1;

    return add32(minus32(del_count_expr), ins_count_expr);
  }
}
