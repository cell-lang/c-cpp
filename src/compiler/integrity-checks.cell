implicit
  block                   : StaticBlock,
  table_var_aux_vars_map  : [TableVar -> (OptAuxTableVar+, Maybe[LocBoolVar])],
  effects_info            : EffectsInfo,
  prg_data                : PrgData,
  rel_vars_perm_map       : [DBSymbol -> [RelVar -> [+Nat -> Nat]]],
  context                 : <core>,
  debug_mode              : Bool,
  skip_integrity_checks   : Bool
{
  Instr* updates_check_code([TableVar] insertion_tables, [TableVar] update_tables, [TableVar] deletion_tables) {
    mutated_tables = insertion_tables & update_tables & deletion_tables;
    // mutated_tables = sort_by_key(mutated_tables, arity(block.tables($)));

    insert_checked_foreign_keys = [k : k s <- block.foreign_keys, s.insertion_checked, insertion_tables(k.origin)];
    insert_checked_foreign_keys = sort_by_key(insert_checked_foreign_keys, order);

    update_checked_foreign_keys = [k : k _ <- block.foreign_keys, update_tables(k.origin)];
    update_checked_foreign_keys = sort_by_key(update_checked_foreign_keys, order);

    delete_checked_foreign_keys = [k : k s <- block.foreign_keys, s.deletion_checked, deletion_tables(k.target)];
    delete_checked_foreign_keys = sort_by_key(delete_checked_foreign_keys, order);

    tables = block.tables;

    key_check_exprs = [];
    key_check_exprs_guards = [];        // key check expr (BoolExpr) -> guard (BoolExpr)
    exprs_extra_info_vars = [];         // key check expr (BoolExpr) -> extra info var (Int32Var)
    extra_info_vars_values = [];        // extra info var (Int32Var) -> extra info expr (Int32Expr)
    extra_info_expr_aux_vars_code = []; // extra info expr (Int32Expr) -> extra info aux vars code (Instr*)

    for v vs <- table_var_aux_vars_map {
      if not insertion_is_forced(v, effects_info) {
        aux_vars, maybe_status_var = vs;
        table = tables(v);
        keys = keys(table);
        for key <- keys {
          expr, maybe_extra_info = key_check_expr_info(v, table, key, aux_vars);
          key_check_exprs = _insert_(key_check_exprs, expr);
          if maybe_extra_info != nothing {
            extra_info_expr, extra_info_var, extra_info_code = value(maybe_extra_info);
            exprs_extra_info_vars = _put_(exprs_extra_info_vars, expr, extra_info_var);
            extra_info_vars_values = _put_(extra_info_vars_values, extra_info_var, extra_info_expr);
            extra_info_expr_aux_vars_code = _put_(extra_info_expr_aux_vars_code, extra_info_expr, extra_info_code);
          }
          if maybe_status_var != nothing {
            status_var = value(maybe_status_var);
            curr_expr = lookup(key_check_exprs_guards, expr, false);
            key_check_exprs_guards = _put_(key_check_exprs_guards, expr, or_else(curr_expr, status_var));
          }
          else
            key_check_exprs_guards = _put_(key_check_exprs_guards, expr, true);
        }
      }
    }

    ord_key_check_exprs = isort(key_check_exprs);

    check_code = ();

    if ord_key_check_exprs != () {
      check_code = (check_code | :empty_line, comment("Checking keys"));

      // Gathering all extra pieces of information to retrieve
      extra_info_exprs = isort([e : _ e <- extra_info_vars_values]);
      for expr <- extra_info_exprs {
        // For each extra piece of information, retrieving all the variables it must be stored in
        vars = isort([v : v <- extra_info_vars_values(?, expr)]);
        // Going from each variables that must store the current piece of information
        // to the expressions that make use of those variables to their guard expressions
        // extra info expr -> (1..*) extra info var -> (1 for now) key check expr -> guard
        guards = [g : v <- vars, e <- exprs_extra_info_vars(?, v), g = key_check_exprs_guards(e)];
        // If any of those guards evaluates to true, then the extra info must be computed
        guard = or_else(isort(nonempty(guards)));
        // Putting it all together
        first_var = vars(0);
        instrs = (set_ivar32(first_var, expr)) & extra_info_expr_aux_vars_code(expr) & (set_ivar32(v, first_var) : v @ i <- drop(vars, 1));
        check_code = check_code & opt_do_if(guard, instrs);
      }

      // Now that all the information we need has been computed, we actually check the expressions
      for e <- ord_key_check_exprs {
        guard = key_check_exprs_guards(e);
        guarded_expr = and_then(guard, e);
        check_code = check_code & opt_do_if(guarded_expr, (ret_val(false)));
      }
    }

    if block.foreign_keys != [] {
      check_code = (check_code | :empty_line, comment("Checking foreign keys"));
      for key info <- block.foreign_keys
        if mutated_tables(key.origin) or mutated_tables(key.target) {
          maybe_foreign_key_check_code = foreign_key_check_code(key, info.insertion_checked, info.deletion_checked);
          check_code = (check_code | :empty_line, comment(block_foreign_key_user_repr(key)));
          check_code = check_code & value_unsafe(maybe_foreign_key_check_code);
        }
    }

    // if insert_checked_foreign_keys != () or update_checked_foreign_keys != () {
    //   check_code = (check_code | :empty_line, comment("Checking foreign keys forward"));
    //   for k <- insert_checked_foreign_keys & update_checked_foreign_keys {
    //     check_expr = foreign_key_forward_check_expr(k);
    //     check_code = (check_code | do_if(check_expr, ret_val(false)));
    //   }
    // }

    // if delete_checked_foreign_keys != () {
    //   check_code = (check_code | :empty_line, comment("Checking foreign keys backward"));
    //   for k <- delete_checked_foreign_keys {
    //     check_expr = foreign_key_backward_check_expr(k);
    //     check_code = (check_code | do_if(check_expr, ret_val(false)));
    //   }
    // }

    check_code = () if skip_integrity_checks;

    return check_code;
  }

  //////////////////////////////////////////////////////////////////////////////

  (BoolExpr, Maybe[(Int32Expr, Int32Var, Instr*)]) key_check_expr_info(TableVar tbl_var, <Table, MasterBinTable, Column, MandatoryColumn> table, [+Nat] key, OptAuxTableVar+ aux_vars) {
    // Default expression
    expr = table_contains(tbl_var, table, (if key(i) then just(cast_int32_var(aux_vars(i))) else nothing : i < arity(table)));

    // Optimization for single-column keys where the column can be replaced with an equivalent column of a unary relation
    ## TODO: AN EQUIVALENT OPTIMIZATION COULD BE DONE FOR MULTI-COLUMN KEYS
    if |key| == 1 {
      col_idx = only(key);
      maybe_equiv_table_var = an_equivalent_unary_table_if_any_exists(tbl_var, col_idx);
      if maybe_equiv_table_var != nothing {
        equiv_table_var = value(maybe_equiv_table_var);
        tmp_key_var = cast_int32_var(aux_vars(col_idx));
        expr = table_contains(equiv_table_var, block.tables(equiv_table_var), (just(tmp_key_var)));
      }
    }

    return (expr, nothing);
  }


  (BoolExpr, Maybe[(Int32Expr, Int32Var, Instr*)]) key_check_expr_info(TableVar tbl_var, <SlaveTernTable, SlaveColumn> table, [+Nat] key, OptAuxTableVar+ aux_vars) {
    assert |aux_vars| == 2 or |aux_vars| == 3;

    if key == [0, 1] {
      if |aux_vars| == 3 {
        master = table.master;
        master_type = cast_master_bin_table(block.tables(master));
        ## TODO: THIS TOO COULD BE OPTIMIZED IN SOME CASES BY JUST CHECKING THE MASTER TABLE
        assoc_surr_var = new_unique_int32_var(:unused);
        expr = and_then(neg(is_null_surr(assoc_surr_var)), table_contains(tbl_var, table, (just(assoc_surr_var), nothing)));
        args = (cast_int32_var(aux_vars(i)) : i <- (0, 1));
        extra_info_expr = get_assoc_surr(table.master, master_type, args);
        extra_info_aux_vars_code = ();
        if table_var_aux_vars_map(master, _) {
          master_aux_vars, master_maybe_status_var = table_var_aux_vars_map(master);
          assert |master_aux_vars| == 3;
          conds = (is_null_surr(assoc_surr_var));
          if master_maybe_status_var != nothing {
            master_status_var = value(master_maybe_status_var);
            conds = (conds | master_status_var);
          }
          conds = conds & (are_eq(args(i), cast_int32_var(master_aux_vars(i))) : i <- (0, 1));
          extra_info_aux_vars_code = (extra_info_aux_vars_code | do_if(and(conds), set_ivar32(assoc_surr_var, cast_int32_var(master_aux_vars(2)))));
        }
        maybe_extra_info = just((extra_info_expr, assoc_surr_var, extra_info_aux_vars_code));
      }
      else {
        expr = table_contains(tbl_var, table, (just(cast_int32_var(aux_vars(0))), nothing));
        maybe_extra_info = nothing;
      }
    }
    else {
      assert key == [2];

      last_col_aux_var = cast_int32_var(last(aux_vars));

      maybe_equiv_table_var = an_equivalent_unary_table_if_any_exists(tbl_var, 2);
      if maybe_equiv_table_var != nothing {
        equiv_table_var = value(maybe_equiv_table_var);
        expr = table_contains(equiv_table_var, block.tables(equiv_table_var), (just(last_col_aux_var)));
      }
      else
        expr = table_contains(tbl_var, table, (nothing, just(last_col_aux_var)));

      maybe_extra_info = nothing;
    }

    return (expr, maybe_extra_info);
  }


  Maybe[TableVar] an_equivalent_unary_table_if_any_exists(TableVar tbl_var, Nat col_idx) {
    tables = block.tables;
    cols_subset_map = block.cols_subset_map;
    relvar = original_rel_var(tbl_var);
    col = phys_col(relvar, col_idx);
    col_equivs = [];
    for c <- cols_subset_map(col, ?) {
      if cols_subset_map(c, col) {
        equiv_table_var = table_var(c.relvar);
        equiv_table = tables(equiv_table_var);
        if arity(equiv_table) == 1
          col_equivs = _insert_(col_equivs, equiv_table_var);
      }
    }
    return if col_equivs != [] then just(any(col_equivs)) else nothing;
  }

  //////////////////////////////////////////////////////////////////////////////

  Maybe[Instr*] foreign_key_check_code(BlockForeignKey key, Bool insertion_checked, Bool deletion_checked) {
    origin = key.origin;
    target = key.target;

    origin_type = block.tables(origin);
    target_type = block.tables(target);

    code = match (key.type)
      binary_unary(i?)      = binary_unary_foreign_key_check_code(i, origin, target, origin_type, target_type, insertion_checked, deletion_checked),
      _                     = nothing;
    return code;
  }

  //////////////////////////////////////////////////////////////////////////////

  BoolExpr foreign_key_forward_check_expr(BlockForeignKey key) {
    origin = key.origin;
    target = key.target;

    origin_type = block.tables(origin);
    target_type = block.tables(target);
    origin_aux_vars, maybe_origin_status_var = table_var_aux_vars_map(origin);

    check_expr = base_check_expr(key.type, origin_type, origin_aux_vars, target, target_type);

    if table_var_aux_vars_map(target, _) {
      target_aux_vars, maybe_target_status_var = table_var_aux_vars_map(target);

      extra_check = extra_check_expr(key.type, origin_type, origin_aux_vars, target_aux_vars, maybe_target_status_var, target, target_type);

      if maybe_target_status_var != nothing {
        target_status_var = value(maybe_target_status_var);
        extra_check = or_else(neg(target_status_var), extra_check);
      }

      check_expr = and(check_expr, extra_check);
    }

    if maybe_origin_status_var != nothing {
      origin_status_var = value(maybe_origin_status_var);
      check_expr = and_then(origin_status_var, check_expr);
    }

    return check_expr;
  }


  BoolExpr std_base_check_expr(ForeignKeyType key_type, OptAuxTableVar+ origin_aux_vars, TableVar target, AnyTable target_type, AnyTable origin_type) {
    assert not origin_type :: <SlaveTernTable, SlaveColumn>;

    args_set = match (key_type)
      unary_unary             = ((just(cast_int32_var(origin_aux_vars(0))))),
      binary_unary(i?)        |
      ternary_unary(i?)       = ((just(cast_int32_var(origin_aux_vars(i))))),
      ternary_binary          = ((just(cast_int32_var(origin_aux_vars(0))), just(cast_int32_var(origin_aux_vars(1))))),
      sym_binary_unary        |
      sym_ternary_unary_12    = ((just(cast_int32_var(origin_aux_vars(j)))) : j < 2),
      sym_ternary_unary_3     = ((just(cast_int32_var(origin_aux_vars(2))))),
      ## BUG BUG BUG: ASSUMING THAT THE TWO SYMMETRIC SURROGATES HAVE BEEN ORDERED. THIS IS CURRENTLY NOT TRUE
      ## IMPLEMENT IT AND ADD A DEBUG MODE CHECK TO VERIFY IT
      sym_ternary_sym_binary  = ((just(cast_int32_var(origin_aux_vars(0))), just(cast_int32_var(origin_aux_vars(1))))),

      unary_binary()          |
      unary_ternary()         |
      binary_ternary          |
      unary_sym_binary        |
      unary_sym_ternary_12    |
      unary_sym_ternary_3     |
      sym_binary_sym_ternary  = undefined;

    return neg(and((table_contains(target, target_type, as) : as <- args_set)));
  }


  BoolExpr std_extra_check_expr(ForeignKeyType key_type, OptAuxTableVar+ origin_aux_vars, OptAuxTableVar+ target_aux_vars, TableVar target, AnyTable target_type, AnyTable origin_type) {
    neg_extra_check = match (key_type)
      unary_unary             = are_eq(cast_int32_var(origin_aux_vars(0)), cast_int32_var(target_aux_vars(0))),
      binary_unary(i?)        |
      ternary_unary(i?)       = are_eq(cast_int32_var(origin_aux_vars(i)), cast_int32_var(target_aux_vars(0))),
      ternary_binary          = and((are_eq(cast_int32_var(origin_aux_vars(j)), cast_int32_var(target_aux_vars(j))) : j < 2)),
      sym_binary_unary        |
      sym_ternary_unary_12    = or((are_eq(cast_int32_var(origin_aux_vars(j)), cast_int32_var(target_aux_vars(0))) : j < 2)),
      sym_ternary_unary_3     = are_eq(cast_int32_var(origin_aux_vars(2)), cast_int32_var(target_aux_vars(0))),
      ## ASSUMING THAT THE TWO SYMMETRIC SURROGATES HAVE BEEN ORDERED. THIS IS CURRENTLY NOT TRUE
      ## IMPLEMENT IT AND ADD A DEBUG MODE CHECK TO VERIFY IT
      sym_ternary_sym_binary  = and((are_eq(cast_int32_var(origin_aux_vars(j)), cast_int32_var(target_aux_vars(j))) : j < 2)),

      unary_binary()          |
      unary_ternary()         |
      binary_ternary          |
      unary_sym_binary        |
      unary_sym_ternary_12    |
      unary_sym_ternary_3     |
      sym_binary_sym_ternary  = undefined; // Statically checked

    return neg(neg_extra_check);
  }


  BoolExpr slave_ternary_to_binary_base_check_expr(<SlaveTernTable, SlaveColumn> origin_type, OptAuxTableVar+ origin_aux_vars, TableVar target, AnyTable target_type) {
    assert |origin_aux_vars| == 2 or |origin_aux_vars| == 3;
    neg_expr = if |origin_aux_vars| == 3
      then table_contains(target, target_type, (just(cast_int32_var(origin_aux_vars(i))) : i <- (0, 1)))
      else master_bin_table_contains_assoc_surr(target, cast_master_bin_table(target_type), cast_int32_var(origin_aux_vars(0)));
    return neg(neg_expr);
  }


  BoolExpr slave_ternary_to_unary_base_check_expr(SlaveTernTable origin_type, OptAuxTableVar+ origin_aux_vars, TableVar target, AnyTable target_type) {
    assert |origin_aux_vars| == 2 or |origin_aux_vars| == 3;
    return neg(table_contains(target, target_type, (just(cast_int32_var(last(origin_aux_vars))))));
  }


  BoolExpr base_check_expr(ForeignKeyType key_type, AnyTable origin_type, OptAuxTableVar+ origin_aux_vars, TableVar target, AnyTable target_type) =
    unary_unary                                   |
    binary_unary()                                |
    sym_binary_unary,         _                   = std_base_check_expr(key_type, origin_aux_vars, target, target_type, origin_type),

    ternary_binary,           table()             = std_base_check_expr(key_type, origin_aux_vars, target, target_type, origin_type),
    ternary_binary,           slave_tern_table()  |
                              slave_column()      = slave_ternary_to_binary_base_check_expr(origin_type, origin_aux_vars, target, target_type),


    ternary_unary(i?),        table()             = std_base_check_expr(key_type, origin_aux_vars, target, target_type, origin_type),
    ternary_unary(2),         slave_tern_table()  = slave_ternary_to_unary_base_check_expr(origin_type, origin_aux_vars, target, target_type),

    sym_ternary_unary_12,     _                   = undefined, ## IMPLEMENT IMPLEMENT IMPLEMENT
    sym_ternary_unary_3,      _                   = undefined, ## IMPLEMENT IMPLEMENT IMPLEMENT
    sym_ternary_sym_binary,   _                   = undefined, ## IMPLEMENT IMPLEMENT IMPLEMENT

    unary_binary()                                |
    unary_ternary()                               |
    binary_ternary                                |
    unary_sym_binary                              |
    unary_sym_ternary_12                          |
    unary_sym_ternary_3                           |
    sym_binary_sym_ternary,   _                   = undefined; // Statically checked


    // ## ASSUMING THAT THE TWO SYMMETRIC SURROGATES HAVE BEEN ORDERED. THIS IS CURRENTLY NOT TRUE
    // ## IMPLEMENT IT AND ADD A DEBUG MODE CHECK TO VERIFY IT



  BoolExpr slave_ternary_to_master_extra_check_expr(ForeignKeyType key_type, OptAuxTableVar+ origin_aux_vars, OptAuxTableVar+ target_aux_vars, TableVar target, AnyTable target_type, <SlaveTernTable, SlaveColumn> origin_type) {
    ## BUG BUG BUG: HERE I MUST MAKE SURE THE TARGET IS THE ACTUAL MASTER. IN THEORY A SLAVE TABLE COULD HAVE A SECOND FOREIGN KEY TO A BINARY TABLE OTHER THAN ITS MASTER
    assert target == origin_type.master;
    assert |origin_aux_vars| == 2 or |origin_aux_vars| == 3;
    assert |target_aux_vars| == 3;

    if |origin_aux_vars| == 2 {
      origin_assoc_surr_var = cast_int32_var(origin_aux_vars(0));
      target_assoc_surr_var = cast_int32_var(target_aux_vars(2));
      return neg(are_eq(origin_assoc_surr_var, target_assoc_surr_var));
    }
    else
      return or((neg(are_eq(cast_int32_var(origin_aux_vars(i)), cast_int32_var(target_aux_vars(i)))) : i <- (0, 1)));
  }


  BoolExpr slave_ternary_to_unary_extra_check_expr(OptAuxTableVar+ origin_aux_vars, OptAuxTableVar+ target_aux_vars, Maybe[LocBoolVar] maybe_target_status_var, TableVar target, AnyTable target_type, SlaveTernTable origin_type) {
    ## BUG BUG BUG: THIS FUNCTION IS PROBABLY BUGGY, BUT TRY TO TRIGGER THE BUG BEFORE TRYING TO FIX IT
    assert |origin_aux_vars| == 2 and |target_aux_vars| == 1;

    origin_aux_var = cast_int32_var(origin_aux_vars(1));
    target_aux_var = cast_int32_var(target_aux_vars(0));
    return neg(are_eq(origin_aux_var, target_aux_var));
  }


  BoolExpr extra_check_expr(ForeignKeyType key_type, AnyTable origin_type, OptAuxTableVar+ origin_aux_vars, OptAuxTableVar+ target_aux_vars, Maybe[LocBoolVar] maybe_target_status_var, TableVar target, AnyTable target_type) =
    unary_unary                                   |
    binary_unary()                                |
    sym_binary_unary,         _                   = std_extra_check_expr(key_type, origin_aux_vars, target_aux_vars, target, target_type, origin_type),

    ternary_binary,           table()             = std_extra_check_expr(key_type, origin_aux_vars, target_aux_vars, target, target_type, origin_type),
    ternary_binary,           slave_tern_table()  |
                              slave_column()      = slave_ternary_to_master_extra_check_expr(key_type, origin_aux_vars, target_aux_vars, target, target_type, origin_type),

    ternary_unary(i?),        table()             = std_extra_check_expr(key_type, origin_aux_vars, target_aux_vars, target, target_type, origin_type),
    ternary_unary(2),         slave_tern_table()  = slave_ternary_to_unary_extra_check_expr(origin_aux_vars, target_aux_vars, maybe_target_status_var, target, target_type, origin_type),

    sym_ternary_unary_12,     _                   = undefined, ## IMPLEMENT IMPLEMENT IMPLEMENT
    sym_ternary_unary_3,      _                   = undefined, ## IMPLEMENT IMPLEMENT IMPLEMENT
    sym_ternary_sym_binary,   _                   = undefined, ## IMPLEMENT IMPLEMENT IMPLEMENT

    unary_binary()                                |
    unary_ternary()                               |
    binary_ternary                                |
    unary_sym_binary                              |
    unary_sym_ternary_12                          |
    unary_sym_ternary_3                           |
    sym_binary_sym_ternary,   _                   = undefined; // Statically checked

  //////////////////////////////////////////////////////////////////////////////

  BoolExpr foreign_key_backward_check_expr(BlockForeignKey key) {
    origin = key.origin;
    target = key.target;

    origin_type = block.tables(origin);
    target_type = block.tables(target);
    target_aux_vars, maybe_target_status_var = table_var_aux_vars_map(target);

    check_expr = match (key.type)
      unary_unary             = undefined,
      unary_binary(i?)        = undefined,
      unary_ternary(i?)       = undefined,
      binary_unary(i?)        = binary_unary_foreign_key_backward_check_expr(i, origin, target, origin_type, target_type),
      ternary_unary(i?)       = undefined,
      binary_ternary          = undefined,
      ternary_binary          = undefined,
      unary_sym_binary        = undefined,
      unary_sym_ternary_12    = undefined,
      unary_sym_ternary_3     = undefined,
      sym_binary_unary        = undefined,
      sym_ternary_unary_12    = undefined,
      sym_ternary_unary_3     = undefined,
      sym_binary_sym_ternary  = undefined,
      sym_ternary_sym_binary  = undefined;

    // check_expr = base_check_expr(key.type, origin_type, origin_aux_vars, target, target_type);

    // if table_var_aux_vars_map(target, _) {
    //   target_aux_vars, maybe_target_status_var = table_var_aux_vars_map(target);

    //   extra_check = extra_check_expr(key.type, origin_type, origin_aux_vars, target_aux_vars, maybe_target_status_var, target, target_type);

    //   if maybe_target_status_var != nothing {
    //     target_status_var = value(maybe_target_status_var);
    //     extra_check = or_else(neg(target_status_var), extra_check);
    //   }

    //   check_expr = and(check_expr, extra_check);
    // }

    // if maybe_origin_status_var != nothing {
    //   origin_status_var = value(maybe_origin_status_var);
    //   check_expr = and_then(origin_status_var, check_expr);
    // }

    return check_expr;
  }


  BoolExpr binary_unary_foreign_key_backward_check_expr(Nat origin_col_idx, TableVar origin, TableVar target, AnyTable origin_type, AnyTable target_type) {
    target_del_args, maybe_target_status_var = table_var_aux_vars_map(target);
    target_del_arg = cast_opt_loc_int32_var(only_unsafe(target_del_args));

    args = (if i == origin_col_idx and target_del_arg != :none then just(target_del_arg) else nothing : i < 2);
    check_expr = table_contains(origin, origin_type, args);

    if effects_info.tables(origin, _) {
      instr_id, action = only_pair(effects_info.tables(origin));
      origin_aux_vars, maybe_origin_status_var = table_var_aux_vars_map(origin);
      assert |origin_aux_vars| == 2;

      if action == :insertion or action == :update {
        if target_del_arg != :none {
          // insert origin(x, y); delete target(x')
          // origin(x, _) -> target(x) | origin(_, y) -> target(y)
          origin_aux_var = cast_int32_var(origin_aux_vars(origin_col_idx));
          extra_check_expr = are_eq(origin_aux_var, target_del_arg);
        }
        else
          extra_check_expr = true;

        if maybe_origin_status_var != nothing {
          origin_status_var = value(maybe_origin_status_var);
          extra_check_expr = and_then(origin_status_var, extra_check_expr);
        }

        check_expr = or_else(check_expr, extra_check_expr);
      }
      else {
        // origin_del_args = match (action) deletion(as?) = as;
        if target_del_arg != :none {
          checked_origin_del_arg = cast_opt_loc_int32_var(origin_aux_vars(origin_col_idx));
          unchecked_origin_del_arg = cast_opt_loc_int32_var(origin_aux_vars(if origin_col_idx == 0 then 1 else 0));

          if checked_origin_del_arg != :none {
            if unchecked_origin_del_arg != :none {
              // delete origin(x, y), delete target(x') : origin(x, _) -> target(x)
              // delete origin(x, y), delete target(y') : origin(_, y) -> target(y)

              args = (maybe(checked_origin_del_arg, i == origin_col_idx) : i < 2);
              get_count_expr = get_count(origin, origin_type, args);

              extra_check_expr = neg(are_eq(get_count_expr, 1));
            }
            else {
              // delete origin(x, *), delete target(x') : origin(x, _) -> target(x)
              // delete origin(*, y), delete target(y') : origin(_, y) -> target(y)

              extra_check_expr = are_eq(checked_origin_del_arg, target_del_arg);
            }
          }
          else {
            if unchecked_origin_del_arg != :none {
              // delete origin(*, y), delete target(x') : origin(x, _) -> target(x);
              // delete origin(x, *), delete target(y') : origin(_, y) -> target(y);

              // |origin(x', y)| == |origin(x', *)|
              // |origin(x, y')| == |origin(*, y')|
              args1 = (just(if i == origin_col_idx then target_del_arg else unchecked_origin_del_arg) : i < 2);
              args2 = (maybe(target_del_arg, i == origin_col_idx) : i < 2);
              count_expr_1 = get_count(origin, origin_type, args1);
              count_expr_2 = get_count(origin, origin_type, args2);
              extra_check_expr = neg(are_eq(count_expr_1, count_expr_2));
            }
            else {
              // delete origin(*, *), delete target(x') : origin(x, _) -> target(x);
              // delete origin(*, *), delete target(y') : origin(_, y) -> target(y);

              extra_check_expr = false;
            }
          }
        }
        else {
          // delete origin(_, _), delete target(*) : origin(x, _)

          args = (if a != :none then just(cast_loc_int32_var(a)) else nothing : a <- origin_aux_vars);
          extra_check_expr = are_eq(
            get_count(origin, origin_type, args),
            get_count(origin, origin_type, (nothing, nothing))
          );
        }

        if maybe_origin_status_var != nothing {
          origin_status_var = value(maybe_origin_status_var);
          extra_check_expr = and_then(origin_status_var, extra_check_expr);
        }

        check_expr = and_then(check_expr, extra_check_expr);
      }
    }

    return check_expr;
  }
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

Nat order(BlockForeignKey key) =
  match (key.type)
    unary_unary             = 0,
    unary_binary(i?)        = i,
    unary_ternary(i?)       = i,

    binary_unary(i?)        = i,
    binary_ternary          = 0,

    ternary_unary(i?)       = i,
    ternary_binary          = 0,

    unary_sym_binary        = 0,
    sym_binary_unary        = 0,

    unary_sym_ternary_12    = 0,
    unary_sym_ternary_3     = 2,

    sym_ternary_unary_12    = 0,
    sym_ternary_unary_3     = 2,

    sym_binary_sym_ternary  = 0,
    sym_ternary_sym_binary  = 0;
