implicit prg_data : PrgData, context : NativeContext, debug_mode : Bool, break_target : Maybe[String] {
  String auto_expr_native_code(RefObjExpr expr, WriteObjVar var) =
    copy_state()              = native_call(var, copy_state_proc_name(expr.type), (native_var_ref_name(expr.var))),
    copy_rel()                = undefined,
    copy_persistent_state()   = native_method_call(var, expr.var, copy_state_proc_name(expr.type), ()),
    read_pending_var(v?)      = native_var_ref_name(var) & " = " & native_var_ref_name(v) & ";";


  String* native_copy_rel_code(WriteObjVar res_var, DBSymbol rel_auto_id, [+TableVar -> AnyTable] tables, [+Nat -> Nat] applied_perm) {
    is_column = only([
      match (t)
        column()  = true,
        _         = false
      : _ t <- tables
    ]);

    is_mandatory_column = only([
      match (t)
        mandatory_column()  = true,
        _                   = false
      : _ t <- tables
    ]);

    is_slave_column = only([
      match (t)
        slave_column()  = true,
        _               = false
      : _ t <- tables
    ]);

    is_master_bin_table = only([
      match (t)
        master_bin_table()  = true,
        _                   = false
      : _ t <- tables
    ]);

    is_slave_tern_table = only([
      match (t)
        slave_tern_table()  = true,
        _                   = false
      : _ t <- tables
    ]);

    symmetric = only([
      match (t)
        table()             |
        master_bin_table()  |
        slave_tern_table()  = t.symmetric,
        mandatory_column()  |
        column()            |
        slave_column()      = false
      : _ t <- tables
    ]);
    assert not symmetric or (applied_perm == [0 -> 0, 1 -> 1] or applied_perm == [0 -> 0, 1 -> 1, 2 -> 2]);

    arity = |applied_perm|;

    table_vars = keys(tables);
    ord_table_vars = isort(table_vars);

    copy_method_name = only([native_table_method_prefix(t) : _ t <- tables]) & "_copy_to";

    if is_column or is_mandatory_column {
      assert applied_perm == [0 -> 0, 1 -> 1] or applied_perm == [0 -> 1, 1 -> 0];
      flipped = applied_perm == [0 -> 1, 1 -> 0];
      streams_args = if flipped then ("&stream_2", "&stream_1") else ("&stream_1", "&stream_2");
      code = ("{ STREAM stream_1, stream_2;", "  init(stream_1);", "  init(stream_2);");
      for v @ i <- ord_table_vars {
        table = tables(v);
        value_store = match (table)
          column()            |
          mandatory_column()  = table.value_store,
          _                   = undefined;
        store_type = prg_data.value_stores(rel_auto_id)(value_store);
        maybe_master_table_arg = match (table)
          mandatory_column()  = (table.master),
          _                   = ();
        args = maybe_master_table_arg & (v, native_surr_to_obj_method_name(store_type), value_store) & streams_args;
        code = (code | "  " & native_call(copy_method_name, args));
      }
      code = (code | "  " & native_call(res_var, if flipped then "build_bin_rel" else "build_map", ("stream_1", "stream_2")), "}");
      return code;
    }
    else if is_slave_column {
      assert applied_perm == [0 -> 0, 1 -> 1, 2 -> 2];
      copy_method_name = "slave_" & copy_method_name;
      unpermutated_stream_args = ("&stream_1", "&stream_2", "&stream_3");
      streams_args = (unpermutated_stream_args(applied_perm(!, i)) : i < 3);
      code = ("{ STREAM stream_1, stream_2, stream_3;", "  init(stream_1);", "  init(stream_2);", "  init(stream_3);");
      for v @ i <- ord_table_vars {
        table = tables(v);
        value_stores, master = match (table)
          slave_column()  = (table.value_stores, table.master),
          _               = undefined;
        stores_types = (prg_data.value_stores(rel_auto_id)(vs) : vs <- value_stores);
        args = (master, v) & join(((native_surr_to_obj_method_name(t), value_stores(j)) : t @ j <- stores_types)) & streams_args;
        code = (code | "  " & native_call(copy_method_name, args));
      }
      code = (code | "  " & native_call(res_var, "build_tern_rel", ("stream_1", "stream_2", "stream_3")), "}");
      return code;
    }
    else if is_master_bin_table {
      assert applied_perm == [0 -> 0, 1 -> 1];
      streams_args = ("&stream_1", "&stream_2");
      code = ("{ STREAM stream_1, stream_2;", "  init(stream_1);", "  init(stream_2);");
      for v <- ord_table_vars {
        value_stores = match (tables(v))
          master_bin_table() t? = t.value_stores,
          _                     = undefined;
        assert |value_stores| == 2;
        store_types = (prg_data.value_stores(rel_auto_id)(vs) : vs <- value_stores);
        method_names = (native_surr_to_obj_method_name(t) : t <- store_types);
        stores_args = join(((method_names(i), vs) : vs @ i <- value_stores));
        args = (v) & stores_args & streams_args;
        code = (code | "  " & native_call(copy_method_name, args));
      }
      code = (code | "  " & native_call(res_var, "build_bin_rel", ("stream_1", "stream_2")), "}");
      return code;
    }
    else if is_slave_tern_table {
      assert applied_perm == [0 -> 0, 1 -> 1, 2 -> 2];
      unpermutated_stream_args = ("&stream_1", "&stream_2", "&stream_3");
      streams_args = (unpermutated_stream_args(applied_perm(!, i)) : i < 3);
      code = (
        "{ STREAM stream_1, stream_2, stream_3;",
        "  init(stream_1);", "  init(stream_2);", "  init(stream_3);"
      );
      for v <- ord_table_vars {
        master, value_stores = match (tables(v))
          slave_tern_table() t? = (t.master, t.value_stores),
          _                     = undefined;
        assert |value_stores| == 3;
        store_types = (prg_data.value_stores(rel_auto_id)(vs) : vs <- value_stores);
        method_names = (native_surr_to_obj_method_name(t) : t <- store_types);
        stores_args = join(((method_names(i), vs) : vs @ i <- value_stores));
        args = (master, v) & stores_args & streams_args;
        code = (code | "  " & native_call(copy_method_name, args));
      }
      code = (code | "  " & native_call(res_var, "build_tern_rel", ("stream_1", "stream_2", "stream_3")), "}");
      return code;
    }
    else if arity == 1 {
      code = ("{ STREAM stream;", "  init(stream);");
      for v @ i <- ord_table_vars {
        value_store = match (tables(v))
          table() t?  = only_unsafe(t.value_stores),
          _           = undefined;
        store_type = prg_data.value_stores(rel_auto_id)(value_store);
        args = (v, native_surr_to_obj_method_name(store_type), value_store, "&stream");
        code = (code | "  " & native_call(copy_method_name, args));
      }
      code = (code | "  " & native_call(res_var, "build_set", ("stream")), "}");
      return code;
    }
    else if arity == 2 {
      if symmetric {
        assert applied_perm == [0 -> 0, 1 -> 1];
        code = ("{ STREAM stream_1, stream_2;", "  init(stream_1);", "  init(stream_2);");
        for v <- ord_table_vars {
          value_store = match (tables(v))
            table() t?  = only([vs : vs <- t.value_stores]),
            _           = undefined;
          store_type = prg_data.value_stores(rel_auto_id)(value_store);
          method_name = native_surr_to_obj_method_name(store_type);
          args = (v, method_name, value_store, "&stream_1", "&stream_2");
          code = (code | "  " & native_call(copy_method_name, args));
        }
        code = (code | "  " & native_call(res_var, "build_bin_rel", ("stream_1", "stream_2")), "}");
        return code;
      }
      else {
        assert applied_perm == [0 -> 0, 1 -> 1] or applied_perm == [0 -> 1, 1 -> 0];
        flipped = applied_perm == [0 -> 1, 1 -> 0];
        streams_args = if flipped then ("&stream_2", "&stream_1") else ("&stream_1", "&stream_2");
        code = ("{ STREAM stream_1, stream_2;", "  init(stream_1);", "  init(stream_2);");
        for v <- ord_table_vars {
          value_stores = match (tables(v))
            table() t?  = t.value_stores,
            _           = undefined;
          assert |value_stores| == 2;
          store_types = (prg_data.value_stores(rel_auto_id)(vs) : vs <- value_stores);
          method_names = (native_surr_to_obj_method_name(t) : t <- store_types);
          stores_args = join(((method_names(i), vs) : vs @ i <- value_stores));
          args = (v) & stores_args & streams_args;
          code = (code | "  " & native_call(copy_method_name, args));
        }
        code = (code | "  " & native_call(res_var, "build_bin_rel", ("stream_1", "stream_2")), "}");
        return code;
      }
    }
    else {
      assert arity == 3 and |applied_perm| == 3;
      assert [i : i _ <- applied_perm] == [0, 1, 2];
      assert [i : _ i <- applied_perm] == [0, 1, 2];
      // 3 = if symmetric then ("SYM_12_TERN_TABLE", "sym_12_tern_table_copy") else ("TERN_TABLE", "tern_table_copy");

      unpermutated_stream_args = ("&stream_1", "&stream_2", "&stream_3");
      streams_args = (unpermutated_stream_args(applied_perm(!, i)) : i < 3);
      code = (
        "{ STREAM stream_1, stream_2, stream_3;",
        "  init(stream_1);", "  init(stream_2);", "  init(stream_3);"
      );
      for v <- ord_table_vars {
        value_stores = table_value_stores(tables(v));
        assert |value_stores| == if symmetric then 2 else 3;
        store_types = (prg_data.value_stores(rel_auto_id)(vs) : vs <- value_stores);
        method_names = (native_surr_to_obj_method_name(t) : t <- store_types);
        stores_args = join(((method_names(i), vs) : vs @ i <- value_stores));
        args = (v) & stores_args & streams_args;
        code = (code | "  " & native_call(copy_method_name, args));
      }
      code = (code | "  " & native_call(res_var, "build_tern_rel", ("stream_1", "stream_2", "stream_3")), "}");
      return code;
    }

    // tables_array_new = "new " & type_name & "[] {" & append(tables_names, ", ") & "}";
    // if is_slave_column {
    //   masters_names = (
    //     match (tables(v))
    //       slave_column() c? = native_var_ref_name(c.master),
    //       _                 = undefined
    //     : v <- ord_table_vars
    //   );
    //   masters_array_new = "new MasterBinaryTable[] {" & append(masters_names, ", ") & "}";
    //   tables_args = (tables_array_new, masters_array_new);
    // }
    // else
    //   tables_args = (tables_array_new);
    // return native_static_call(res_var, struct_name & ".copy", tables_args & perm_args);
  }


  String* auto_instr_native_code(Instr instr, Maybe[Nat] block_id) =
    try_block()           = native_try_block_code(instr.var, instr.body, block_id),

    queue_node_update()   = (native_method_call("this", queue_node_update_method_name(instr.type, instr.id), instr.args)),

    insert_timer()        = (native_method_call("this", insert_timer_method_name(instr.type), (instr.idx, instr.time))),
    clear_timer()         = (native_method_call("this", clear_timer_method_name(instr.type), (instr.idx))),

    auto_pre_init()       = (native_new_call(instr.var, native_name(instr.type), ("env"))),
    auto_cleanup()        = (), //(native_method_call(instr.var, cleanup_method_name(instr.type), ())),
    clear_input()         = (native_method_call(if instr.var? then instr.var else "this", input_set_method_name(instr.type, instr.input), ("NullObj.singleton"))),
    auto_update_node()    = (native_method_call("this", node_update_method_name(instr.type, instr.node), (instr.time_var if instr.time_var?, "env"))),

    set_input()           = (native_method_call(instr.var, input_set_method_name(instr.type, instr.input), (instr.value))),
    auto_apply()          = (native_method_call(if instr.var? then instr.var else "this", apply_method_name(instr.type), ("env"))),

    set_persistent_state()  = (native_method_call(instr.auto_var, set_state_proc_name(instr.type), (instr.state))),

    init_db()             = native_init_db_code(instr.db_var, instr.links, instr.type),
    cleanup_db()          = (), //(native_method_call(instr.db_var, cleanup_method_name(instr.type), ())),

    send_external_msg()   = native_send_external_msg_code(instr.db_var, instr.type, instr.msg, instr.res_var, instr.handler_id),
    send_internal_msg()   = native_send_internal_msg_code(instr.db_var, instr.type, instr.msg, instr.handler_id),

    set_state()           = native_set_state_code(instr.state, instr.db_var, instr.type, instr.res_var),
    invoke_auto_method()  = (native_method_call(instr.res_var, if instr.auto_var? then instr.auto_var else "this", user_def_method_name(instr.type, instr.method_id), (instr.args | "env"))),
    invoke_db_method()    = native_invoke_db_method_code(instr.res_var, if instr.db_var? then just(instr.db_var) else nothing, instr.type, instr.method_id, instr.args),

    init_value_store()    = (), //(native_method_call(instr.store,   "init",    ())),
    cleanup_value_store() = (), //(native_method_call(instr.store,   "cleanup", ())),
    init_table()          = (), //(native_method_call(instr.rel_var, "init",    ())),
    cleanup_table()       = (), //(native_method_call(instr.rel_var, "cleanup", ())),

    queue_deletes()       = (native_queue_deletes_code(instr.table_var, instr.table, instr.args, instr.symmetric)),
    lookup_or_queue_insert_value() = (native_call(instr.res_var, native_value_store_method_prefix(instr.store_type) & "_aux_lookup_or_insert_value", (instr.store, updater_var_ref_name(instr.store), :mem_pool, instr.value))),
    queue_insert_tuple()  = (native_queue_insert_tuple_code(instr.table_var, instr.table, instr.tuple)),

    column_insert_deferred() = native_column_insert_deferred_code(instr.table_var, instr.mandatory, instr.col_repr, instr.key_surr, instr.value, instr.forced),
    // ternary_slave_column_insert_deferred() = native_ternary_slave_column_insert_deferred_code(instr.table_var, instr.col_repr, instr.surrs, instr.value, instr.forced),

    immediate_insert_or_add_ref() = native_immediate_insert_or_add_ref(instr.res_var, instr.store, instr.store_type, instr.value),
    immediate_insert_tuple() = native_immediate_insert_tuple(instr.table_var, instr.table, instr.tuple),
    column_insert_immediate() = native_column_insert_immediate_code(instr.table_var, instr.mandatory, instr.col_repr, instr.key_surr, instr.value),

    resize_mandatory_column() = native_resize_mandatory_column_code(instr.table_var, instr.column, instr.curr_capacity, instr.new_capacity),
    raise_load_error()        = ("return false;"),
    surr_set_try_insert()     = (native_call(instr.was_new, "surr_set_try_insert", ("&surr_set", instr.surr))),
    surr_set_clear            = (native_call("surr_set_clear", ("&surr_set")));


  String* native_resize_mandatory_column_code(AnyTableVar table_var, MandatoryColumn column, Int32Expr curr_capacity, Int32Expr new_capacity) {
    method_name = native_table_method_prefix(column) & "_resize";
    args = (table_var, curr_capacity, new_capacity, :mem_pool);
    return (native_call(method_name, args));
  }

  String* native_invoke_db_method_code(AnyWriteVar res_var, Maybe[AnyDBVar] maybe_db_var, DBSymbol type, MethodId method_id, AnyTypeExpr* args) {
    db_var_name = if maybe_db_var != nothing
      then native_var_ref_name(value(maybe_db_var))
      else auto_or_db_arg_name;
    native_args = (db_var_name) & args & ("env");
    return (native_call(res_var, user_def_method_name(type, method_id), native_args));
  }


  String* native_column_insert_immediate_code(TableVar table_var, Bool mandatory, ColumnRepr col_repr, Int32Var key_surr, AnyTypeExpr value) {
    return (native_call(native_column_method_prefix(col_repr, mandatory) & "_insert", (table_var, key_surr, value, :mem_pool)));
  }


  String* native_column_insert_deferred_code(TableVar table_var, Bool mandatory, ColumnRepr col_repr, Int32Var key_surr, AnyTypeExpr value, Bool forced) {
    updater = pending_updates_var_ref_name(table_var);
    method_name = native_column_method_prefix(col_repr) & if forced then "_aux_update" else "_aux_insert";
    return (native_call(method_name, (updater, key_surr, value)));
  }


  // String* native_ternary_slave_column_insert_deferred_code(TableVar table_var, ColumnRepr col_repr, (Int32Var, Int32Var) surrs, AnyTypeExpr value, Bool forced) {
  //   updater = pending_updates_var_ref_name(table_var);
  //   method_name = native_column_method_prefix(col_repr) & if forced then "_aux_update" else "_aux_insert";
  //   return (native_call(method_name, (updater) & (surrs | value)));
  // }


  String* native_immediate_insert_or_add_ref(Int32Var res_var, ValueStoreId store, ValueStoreType store_type, <AtomicExpr, IntExpr> value) =
    (native_call(res_var, native_value_store_method_prefix(store_type) & "_insert_or_add_ref", (store, :mem_pool, value)));


  String* native_immediate_insert_tuple(TableVar table_var, AnySurrTable table, Int32Var+ tuple) {
    method_name = native_table_method_prefix(table) & "_insert";
    return (native_call(method_name, (table.master if table :: SlaveTernTable, table_var) & tuple & (:mem_pool)));
  }


  String native_queue_insert_tuple_code(TableVar table_var, AnySurrTable table, Int32Var+ tuple) {
    updater = pending_updates_var_ref_name(table_var);
    args = match (table)
      master_bin_table()  = (table_var, updater),
      slave_tern_table()  = (table.master, pending_updates_var_ref_name(table.master), updater),
      table()             = (table_var if arity(table) == 3, updater),
      _                   = (updater);
    args = args & tuple;
    return native_call(native_table_method_prefix(table) & "_aux_insert", args);
  }


  String* native_init_db_code(AnyDBVar db_var, LocDBVar* links, DBSymbol db_type) {
    fail if not db_var :: LocDBVar;

    args = (db_var) & links & ("env");
    aux_args = (db_var, updater_var_ref_name(db_var)) & (updater_var_ref_name(l) : l <- links);
    return (native_call(init_method_name(db_type), args), native_call(aux_init_method_name(db_type), aux_args));

    // return (
    //   native_new_call(db_var, native_name(db_type), (links | "env")),
    //   native_method_call(
    //     updater_var_ref_name(db_var),
    //     db_var,
    //     updater_creation_proc_name(db_type),
    //     (updater_var_ref_name(d) : d <- links)
    //   ) if db_var :: LocDBVar
    // );
  }


  String* native_try_block_code(LocVar var, Instr+ body, Maybe[Nat] block_id) = (
    "try {"
  ) & indent_lines(native_code(body, block_id)) & (
    "}",
    "catch (Exception e) {",
    "  " & native_var_ref_name(var) & " = NullObj.singleton;",
    "}"
  );


  // String native_set_table_code(RelVar relvar, Table table, AtomicExpr state, Nat+ perm) {
  //   perm_args = match (perm)
  //     (_)       = (),
  //     (0, 1)    = (false),
  //     (1, 0)    = (true),
  //     (_, _, _) = perm;
  //   // args = (pending_updates_var_ref_name(relvar)) & table.value_stores &
  //   //        (updater_var_ref_name(vs) : vs <- table.value_stores) & perm_args;
  //   return native_method_call(pending_updates_var_ref_name(table_var(relvar)), "set", (state) & perm_args);
  // }


  String native_queue_deletes_code(TableVar table_var, AnyTable table, Maybe[Int32Var]+ args, Bool symmetric) {
    set_args = (a != nothing : a <- args);
    base_names = if symmetric then sym_fn_names_by_args else fn_names_by_args;
    prefix = match (table)
      mandatory_column()  = if set_args == (true, false)
                              then native_table_method_prefix(table)
                              else native_column_method_prefix(table.repr),
      _                   = native_table_method_prefix(table);
    method_name = prefix & "_aux_" & base_names(set_args);
    auxiliary = pending_updates_var_ref_name(table_var);
    ad_hoc_args = match (table)
      table()             = ( table_var if match (set_args)
                                (false)             |
                                (true, true)        |
                                (true, _,    _)     |
                                (_,    true, _)     |
                                (_,    _,    true)  = true,
                                _                   = false
                            ),
      master_bin_table()  = (table_var if set_args == (true, true)),
      slave_tern_table()  = (table.master if set_args != (false, false, false)),
      column()            = (table_var if set_args == (true, false)),
      slave_column()      = (table_var if set_args == (true, false)),
      mandatory_column()  = (table.master if set_args == (true, false)),
      _                   = ();
    call_args = (ad_hoc_args | auxiliary) & (native_expr(value(a)) : a <- args, a != nothing);
    return native_call(method_name, call_args);

    [Bool+ -> String] fn_names_by_args = [
      (true)                  -> "delete",
      (false)                 -> "clear",
      (true,  true)           -> "delete",
      (true,  false)          -> "delete_1",
      (false, true)           -> "delete_2",
      (false, false)          -> "clear",
      (true,  true,  true)    -> "delete",
      (true,  true,  false)   -> "delete_12",
      (true,  false, true)    -> "delete_13",
      (false, true,  true)    -> "delete_23",
      (true,  false, false)   -> "delete_1",
      (false, true,  false)   -> "delete_2",
      (false, false, true)    -> "delete_3",
      (false, false, false)   -> "clear"
    ];

    [Bool+ -> String] sym_fn_names_by_args = [
      (true,  true)           -> "delete",
      (true,  false)          -> "delete_1",
      // (false, true)           -> undefined,
      (false, false)          -> "clear",
      (true,  true,  true)    -> "delete",
      (true,  true,  false)   -> "delete_12",
      (true,  false, true)    -> "delete_13_23",
      (false, true,  true)    -> "delete_13_23",
      (true,  false, false)   -> "delete_1_2",
      (false, true,  false)   -> "delete_1_2",
      (false, false, true)    -> "delete_3",
      (false, false, false)   -> "clear"
    ];
  }


  String* native_send_external_msg_code(LocDBVar db_var, DBSymbol db_type, AtomicExpr msg, BoolVar res_var, Maybe[HandlerId] maybe_handler_id) {
    if maybe_handler_id == nothing {
      methods_array_name = msg_handler_entry_point_array(db_type);
      resolver_name = handler_dispatch_resolver_name(db_type);
      handler_name_or_method_pointer_lookup_expr = methods_array_name & "[" & resolver_name & "(" & native_expr(msg) & ")]";
    }
    else {
      handler_id = value(maybe_handler_id);
      handler_name_or_method_pointer_lookup_expr = msg_handler_entry_point_name(db_type, handler_id);
    }

    db_var_name = native_var_ref_name(db_var);
    aux_var_name = aux_var_decl_name(db_var);
    args = (db_var_name, aux_var_name, msg, "env");
    line = native_call(res_var, handler_name_or_method_pointer_lookup_expr, args);
    return (line);
  }


  String* native_send_internal_msg_code(LinkedDBVar db_var, DBSymbol db_type, AtomicExpr msg, Maybe[HandlerId] maybe_handler_id) {
    if maybe_handler_id == nothing {
      methods_array_name = msg_handler_array(db_type);
      resolver_name = handler_dispatch_resolver_name(db_type);
      handler_name_or_method_pointer_lookup_expr = methods_array_name & "[" & resolver_name & "(" & native_expr(msg) & ")]";
    }
    else {
      handler_id = value(maybe_handler_id);
      handler_name_or_method_pointer_lookup_expr = native_name(db_type, handler_id);
    }

    db_var_name = native_var_ref_name(db_var);
    aux_var_name = pending_updates_var_ref_name(db_var);
    msg_var = dependee_msg_var_ref_name(db_var);

    args = (db_var_name, aux_var_name, msg, "env");
    call_expr = native_call_expr(handler_name_or_method_pointer_lookup_expr, args);
    return (
      "// HERE HERE HERE",
      "if (!is_blank(" & msg_var & "))",
      "  return false;",
      msg_var & " = " & native_expr(msg) & ";",
      "if (!" & call_expr & ")",
      "  return false;"
    );




    // method_name = update_name(db_type, main_handler);
    // aux_db_var_name = updater_var_ref_name(db_var);
    // msg_var_name = dependee_msg_var_ref_name(db_var);
    // return (
    //   "if (!is_blank(" & msg_var_name & "))",
    //   "  soft_fail(NULL);",
    //   msg_var_name & " = " & native_expr(msg) & ";"
    // );
  }


  String* native_set_state_code(AtomicExpr state, LocDBVar db_var, DBSymbol db_type, BoolVar res_var) {
    method_name = set_state_entry_point_name(db_type);
    args = (native_var_ref_name(db_var), updater_var_ref_name(db_var), state, "env");
    return (native_call(res_var, method_name, args));
  }
}
