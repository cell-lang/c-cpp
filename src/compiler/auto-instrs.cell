implicit prg_data : PrgData, context : NativeContext, debug_mode : Bool, break_target : Maybe[String] {
  String auto_expr_native_code(RefObjExpr expr, WriteObjVar var) =
    copy_state()              = native_call(var, copy_state_method_name(expr.type), (native_var_ref_name(expr.var))),
    copy_rel()                = undefined,
    copy_persistent_state()   = native_call(var, copy_state_method_name(expr.type), (expr.var)),
    read_pending_var(v?)      = native_var_ref_name(var) & " = " & native_var_ref_name(v) & ";";


  String* native_copy_rel_code(WriteObjVar res_var, DBSymbol rel_auto_id, [+TableVar -> AnyTable] tables, [+Nat -> Nat] applied_perm) {
    is_column = only([
      match (t)
        column()  = true,
        _         = false
      : _ t <- tables
    ]);

    is_mandatory_column = only([
      match (t)
        mandatory_column()  = true,
        _                   = false
      : _ t <- tables
    ]);

    is_slave_column = only([
      match (t)
        slave_column()  = true,
        _               = false
      : _ t <- tables
    ]);

    is_master_bin_table = only([
      match (t)
        master_bin_table()  = true,
        _                   = false
      : _ t <- tables
    ]);

    is_slave_tern_table = only([
      match (t)
        slave_tern_table()  = true,
        _                   = false
      : _ t <- tables
    ]);

    symmetric = only([
      match (t)
        table()             |
        master_bin_table()  |
        slave_tern_table()  = t.symmetric,
        mandatory_column()  |
        column()            |
        slave_column()      = false
      : _ t <- tables
    ]);
    assert not symmetric or (applied_perm == [0 -> 0, 1 -> 1] or applied_perm == [0 -> 0, 1 -> 1, 2 -> 2]);

    arity = |applied_perm|;

    table_vars = keys(tables);
    ord_table_vars = isort(table_vars);

    copy_method_name = only([native_table_method_prefix(t) : _ t <- tables]) & "_copy_to";

    if is_column or is_mandatory_column {
      assert applied_perm == [0 -> 0, 1 -> 1] or applied_perm == [0 -> 1, 1 -> 0];
      flipped = applied_perm == [0 -> 1, 1 -> 0];
      streams_args = if flipped then ("&stream_2", "&stream_1") else ("&stream_1", "&stream_2");
      code = ("{ STREAM stream_1, stream_2;", "  init(stream_1);", "  init(stream_2);");
      for v @ i <- ord_table_vars {
        table = tables(v);
        value_store = match (table)
          column()            |
          mandatory_column()  = table.value_store,
          _                   = undefined;
        store_type = prg_data.value_stores(rel_auto_id)(value_store);
        maybe_master_table_arg = match (table)
          mandatory_column()  = (table.master),
          _                   = ();
        args = maybe_master_table_arg & (v, native_surr_to_obj_method_name(store_type), value_store) & streams_args;
        code = (code | "  " & native_call(copy_method_name, args));
      }
      code = (code | "  " & native_call(res_var, if flipped then "build_bin_rel" else "build_map", ("stream_1", "stream_2")), "}");
      return code;
    }
    else if is_slave_column {
      assert applied_perm == [0 -> 0, 1 -> 1, 2 -> 2];
      copy_method_name = "slave_" & copy_method_name;
      unpermutated_stream_args = ("&stream_1", "&stream_2", "&stream_3");
      streams_args = (unpermutated_stream_args(applied_perm(!, i)) : i < 3);
      code = ("{ STREAM stream_1, stream_2, stream_3;", "  init(stream_1);", "  init(stream_2);", "  init(stream_3);");
      for v @ i <- ord_table_vars {
        table = tables(v);
        value_stores, master = match (table)
          slave_column()  = (table.value_stores, table.master),
          _               = undefined;
        stores_types = (prg_data.value_stores(rel_auto_id)(vs) : vs <- value_stores);
        args = (master, v) & join(((native_surr_to_obj_method_name(t), value_stores(j)) : t @ j <- stores_types)) & streams_args;
        code = (code | "  " & native_call(copy_method_name, args));
      }
      code = (code | "  " & native_call(res_var, "build_tern_rel", ("stream_1", "stream_2", "stream_3")), "}");
      return code;
    }
    else if is_master_bin_table {
      assert applied_perm == [0 -> 0, 1 -> 1];
      streams_args = ("&stream_1", "&stream_2");
      code = ("{ STREAM stream_1, stream_2;", "  init(stream_1);", "  init(stream_2);");
      for v <- ord_table_vars {
        value_stores = match (tables(v))
          master_bin_table() t? = t.value_stores,
          _                     = undefined;
        assert |value_stores| == 2;
        store_types = (prg_data.value_stores(rel_auto_id)(vs) : vs <- value_stores);
        method_names = (native_surr_to_obj_method_name(t) : t <- store_types);
        stores_args = join(((method_names(i), vs) : vs @ i <- value_stores));
        args = (v) & stores_args & streams_args;
        code = (code | "  " & native_call(copy_method_name, args));
      }
      code = (code | "  " & native_call(res_var, "build_bin_rel", ("stream_1", "stream_2")), "}");
      return code;
    }
    else if is_slave_tern_table {
      assert applied_perm == [0 -> 0, 1 -> 1, 2 -> 2];
      unpermutated_stream_args = ("&stream_1", "&stream_2", "&stream_3");
      streams_args = (unpermutated_stream_args(applied_perm(!, i)) : i < 3);
      code = (
        "{ STREAM stream_1, stream_2, stream_3;",
        "  init(stream_1);", "  init(stream_2);", "  init(stream_3);"
      );
      for v <- ord_table_vars {
        master, value_stores = match (tables(v))
          slave_tern_table() t? = (t.master, t.value_stores),
          _                     = undefined;
        assert |value_stores| == 3;
        store_types = (prg_data.value_stores(rel_auto_id)(vs) : vs <- value_stores);
        method_names = (native_surr_to_obj_method_name(t) : t <- store_types);
        stores_args = join(((method_names(i), vs) : vs @ i <- value_stores));
        args = (master, v) & stores_args & streams_args;
        code = (code | "  " & native_call(copy_method_name, args));
      }
      code = (code | "  " & native_call(res_var, "build_tern_rel", ("stream_1", "stream_2", "stream_3")), "}");
      return code;
    }
    else if arity == 1 {
      code = ("{ STREAM stream;", "  init(stream);");
      for v @ i <- ord_table_vars {
        value_store = match (tables(v))
          table() t?  = only_unsafe(t.value_stores),
          _           = undefined;
        store_type = prg_data.value_stores(rel_auto_id)(value_store);
        args = (v, native_surr_to_obj_method_name(store_type), value_store, "&stream");
        code = (code | "  " & native_call(copy_method_name, args));
      }
      code = (code | "  " & native_call(res_var, "build_set", ("stream")), "}");
      return code;
    }
    else if arity == 2 {
      if symmetric {
        assert applied_perm == [0 -> 0, 1 -> 1];
        code = ("{ STREAM stream_1, stream_2;", "  init(stream_1);", "  init(stream_2);");
        for v <- ord_table_vars {
          value_store = match (tables(v))
            table() t?  = only([vs : vs <- t.value_stores]),
            _           = undefined;
          store_type = prg_data.value_stores(rel_auto_id)(value_store);
          method_name = native_surr_to_obj_method_name(store_type);
          args = (v, method_name, value_store, "&stream_1", "&stream_2");
          code = (code | "  " & native_call(copy_method_name, args));
        }
        code = (code | "  " & native_call(res_var, "build_bin_rel", ("stream_1", "stream_2")), "}");
        return code;
      }
      else {
        assert applied_perm == [0 -> 0, 1 -> 1] or applied_perm == [0 -> 1, 1 -> 0];
        flipped = applied_perm == [0 -> 1, 1 -> 0];
        streams_args = if flipped then ("&stream_2", "&stream_1") else ("&stream_1", "&stream_2");
        code = ("{ STREAM stream_1, stream_2;", "  init(stream_1);", "  init(stream_2);");
        for v <- ord_table_vars {
          value_stores = match (tables(v))
            table() t?  = t.value_stores,
            _           = undefined;
          assert |value_stores| == 2;
          store_types = (prg_data.value_stores(rel_auto_id)(vs) : vs <- value_stores);
          method_names = (native_surr_to_obj_method_name(t) : t <- store_types);
          stores_args = join(((method_names(i), vs) : vs @ i <- value_stores));
          args = (v) & stores_args & streams_args;
          code = (code | "  " & native_call(copy_method_name, args));
        }
        code = (code | "  " & native_call(res_var, "build_bin_rel", ("stream_1", "stream_2")), "}");
        return code;
      }
    }
    else {
      assert arity == 3 and |applied_perm| == 3;
      assert [i : i _ <- applied_perm] == [0, 1, 2];
      assert [i : _ i <- applied_perm] == [0, 1, 2];
      // 3 = if symmetric then ("SYM_12_TERN_TABLE", "sym_12_tern_table_copy") else ("TERN_TABLE", "tern_table_copy");

      unpermutated_stream_args = ("&stream_1", "&stream_2", "&stream_3");
      streams_args = (unpermutated_stream_args(applied_perm(!, i)) : i < 3);
      code = (
        "{ STREAM stream_1, stream_2, stream_3;",
        "  init(stream_1);", "  init(stream_2);", "  init(stream_3);"
      );
      for v <- ord_table_vars {
        value_stores = table_value_stores(tables(v));
        assert |value_stores| == if symmetric then 2 else 3;
        store_types = (prg_data.value_stores(rel_auto_id)(vs) : vs <- value_stores);
        method_names = (native_surr_to_obj_method_name(t) : t <- store_types);
        stores_args = join(((method_names(i), vs) : vs @ i <- value_stores));
        args = (v) & stores_args & streams_args;
        code = (code | "  " & native_call(copy_method_name, args));
      }
      code = (code | "  " & native_call(res_var, "build_tern_rel", ("stream_1", "stream_2", "stream_3")), "}");
      return code;
    }

    // tables_array_new = "new " & type_name & "[] {" & append(tables_names, ", ") & "}";
    // if is_slave_column {
    //   masters_names = (
    //     match (tables(v))
    //       slave_column() c? = native_var_ref_name(c.master),
    //       _                 = undefined
    //     : v <- ord_table_vars
    //   );
    //   masters_array_new = "new MasterBinaryTable[] {" & append(masters_names, ", ") & "}";
    //   tables_args = (tables_array_new, masters_array_new);
    // }
    // else
    //   tables_args = (tables_array_new);
    // return native_static_call(res_var, struct_name & ".copy", tables_args & perm_args);
  }


  String* auto_instr_native_code(Instr instr, Maybe[Nat] block_id) =
    try_block()           = native_try_block_code(instr.var, instr.body, block_id),

    queue_node_update()   = (native_call(queue_node_update_method_name(instr.type, instr.id), (auto_or_db_arg_name) & instr.args)),

    insert_timer()        = (native_call(insert_timer_method_name(instr.type), (auto_or_db_arg_name, instr.idx, instr.time))),
    clear_timer()         = (native_call(clear_timer_method_name(instr.type), (auto_or_db_arg_name, instr.idx))),

    auto_pre_init()       = native_auto_pre_init_code(instr.var, instr.type),
    auto_cleanup()        = (native_call(cleanup_method_name(instr.type), (instr.var))),
    clear_input()         = (native_call(input_set_method_name(instr.type, instr.input), (auto_or_db_arg_name, "make_null_obj()"))),
    auto_update_node()    = (native_call(node_update_method_name(instr.type, instr.node), (auto_or_db_arg_name, instr.time_var if instr.time_var?, "env"))),

    set_input()           = (native_call(input_set_method_name(instr.type, instr.input), (instr.var, instr.value))),
    auto_apply()          = (native_call(apply_method_name(instr.type), (if instr.var? then instr.var else auto_or_db_arg_name, "env"))),

    set_persistent_state()  = (native_call(set_state_method_name(instr.type), (instr.auto_var, instr.state))),

    init_db()             = native_init_db_code(instr.db_var, instr.links, instr.type),
    cleanup_db()          = (native_call(cleanup_method_name(instr.type), (instr.db_var, updater_var_ref_name(instr.db_var)))),

    send_external_msg()   = native_send_external_msg_code(instr.db_var, instr.type, instr.msg, instr.res_var, instr.handler_id),
    send_internal_msg()   = native_send_internal_msg_code(instr.db_var, instr.type, instr.msg, instr.handler_id),

    set_state()           = native_set_state_code(instr.state, instr.db_var, instr.type, instr.res_var),
    invoke_auto_method()  = (native_call(instr.res_var, user_def_method_name(instr.type, instr.method_id), (if instr.auto_var? then instr.auto_var else auto_or_db_arg_name) & (instr.args | "env"))),
    invoke_db_method()    = native_invoke_db_method_code(instr.res_var, if instr.db_var? then just(instr.db_var) else nothing, instr.type, instr.method_id, instr.args),

    init_value_store()    = (), //(native_call("init",    (instr.store))),
    cleanup_value_store() = (), //(native_call("cleanup", (instr.store))),
    init_table()          = (), //(native_call("init",    (instr.rel_var))),
    cleanup_table()       = (), //(native_call("cleanup", (instr.rel_var))),

    queue_deletes()       = (native_queue_deletes_code(instr.table_var, instr.table, instr.args)),
    lookup_or_queue_insert_value() = (native_call(instr.res_var, native_value_store_method_prefix(instr.store_type) & "_aux_lookup_or_insert_value", (instr.store, updater_var_ref_name(instr.store), instr.value, :mem_pool))),
    queue_insert_tuple()  = native_queue_insert_tuple_code(instr.table_var, instr.table, instr.tuple, instr.forced),
    queue_insert_master_tuple() = (native_queue_insert_master_tuple_code(instr.assoc_surr_var, instr.table_var, instr.table, instr.tuple)),

    column_insert_deferred() = native_column_insert_deferred_code(instr.table_var, instr.column, instr.key_surr, instr.args_surrs, instr.value, instr.forced),

    immediate_insert_or_add_ref() = native_immediate_insert_or_add_ref(instr.res_var, instr.store, instr.store_type, instr.value),
    immediate_delete_tuple()  = native_immediate_delete_tuple_code(instr.table_var, instr.table, instr.tuple),
    immediate_insert_tuple()  = native_immediate_insert_tuple_code(instr.table_var, instr.table, instr.tuple),
    immediate_update_tuple()  = native_immediate_update_tuple_code(instr.table_var, instr.table, instr.tuple, instr.owned_value_stores),
    column_insert_immediate() = native_column_insert_immediate_code(instr.table_var, instr.column, instr.key_surr, instr.value, instr.forced),

    release_before_delete()   = native_release_before_delete_code(instr.table_var, instr.table, instr.args, instr.col_idx, instr.store, instr.store_type),

    value_store_release()     = native_value_store_release_code(instr.store, instr.store_type, instr.surr),
    value_store_clear()       = native_value_store_clear_code(instr.store, instr.store_type),
    value_store_apply()       = native_value_store_apply_code(instr.store, instr.store_type),

    resize_mandatory_column() = native_resize_mandatory_column_code(instr.table_var, instr.column, instr.curr_capacity, instr.new_capacity),
    raise_load_error()        = ("return false;"),
    surr_set_try_insert()     = (native_call(instr.was_new, "surr_set_try_insert", ("&surr_set", instr.surr))),
    surr_set_clear            = (native_call("surr_set_clear", ("&surr_set")));


  String* native_auto_pre_init_code(AnyAutoVar var, AutoSymbol type) {
    method_name = pre_init_method_name(type);
    return (native_call(method_name, (var, "env")));
  }


  String* native_resize_mandatory_column_code(AnyTableVar table_var, MandatoryColumn column, Int32Expr curr_capacity, Int32Expr new_capacity) {
    method_name = native_table_method_prefix(column) & "_resize";
    args = (table_var, curr_capacity, new_capacity, :mem_pool);
    return (native_call(method_name, args));
  }


  String* native_invoke_db_method_code(AnyWriteVar res_var, Maybe[AnyDBVar] maybe_db_var, DBSymbol type, MethodId method_id, AnyTypeExpr* args) {
    db_var_name = if maybe_db_var != nothing
      then native_var_ref_name(value(maybe_db_var))
      else auto_or_db_arg_name;
    native_args = (db_var_name) & args & ("env");
    return (native_call(res_var, user_def_method_name(type, method_id), native_args));
  }


  String* native_column_insert_immediate_code(TableVar table_var, MandatoryColumn column, Int32Var key_surr, AnyTypeExpr value, Bool forced) {
    method_name = native_column_method_prefix(column.repr, true) & "_" & if forced then "update" else "insert";
    args = (column.master if forced, table_var, key_surr, value, :mem_pool);
    return (native_call(method_name, args));
  }


  String* native_column_insert_immediate_code(TableVar table_var, <Column, SlaveColumn> column, Int32Var key_surr, AnyTypeExpr value, Bool forced) {
    method_name = native_column_method_prefix(column.repr, false) & "_" & if forced then "update" else "insert";
    args = (table_var, key_surr, value, :mem_pool);
    return (native_call(method_name, args));
  }


  String* native_column_insert_deferred_code(TableVar table_var, AnyColumn column, Int32Var key_surr, Maybe[(Int32Var, Int32Var)] args_surrs, AnyTypeExpr value_expr, Bool forced) {
    aux_struct = pending_updates_var_ref_name(table_var);
    method_name_prefix = native_table_method_prefix(column);

    if args_surrs == nothing {
      method_name = method_name_prefix & if forced then "_aux_update" else "_aux_insert";
      args = match (column)
        mandatory_column()  = (column.master),
        column()            |
        slave_column()      = (table_var);
      args = (args | aux_struct, key_surr, value_expr);
    }
    else {
      fail if not column :: SlaveColumn;
      method_name = method_name_prefix & if forced then "_aux_slave_update" else "_aux_slave_insert";
      master_aux_struct = pending_updates_var_ref_name(column.master);
      arg1_surr, arg2_surr = value(args_surrs);
      args = (table_var, aux_struct, column.master, master_aux_struct, arg1_surr, arg2_surr, value_expr);
    }

    return (native_call(method_name, args));
  }


  String* native_immediate_insert_or_add_ref(Int32Var res_var, ValueStoreId store, ValueStoreType store_type, <AtomicExpr, IntExpr> value) =
    (native_call(res_var, native_value_store_method_prefix(store_type) & "_lookup_or_insert", (store, value, :mem_pool)));


  String* native_immediate_insert_tuple_code(TableVar table_var, Table table, Int32Var+ tuple) {
    method_name = native_table_method_prefix(table) & "_insert";
    args = (table_var) & tuple & (:mem_pool);
    return (native_call(method_name, args));
  }


  String* native_immediate_insert_tuple_code(TableVar table_var, MasterBinTable table, Int32Var+ tuple) {
    method_action_descr = if |tuple| == 3 then "_insert_using_first_free_surr" else "_insert";
    method_name = native_table_method_prefix(table) & method_action_descr;
    args = (table_var) & tuple & (:mem_pool);
    return (native_call(method_name, args));
  }


  String* native_immediate_insert_tuple_code(TableVar table_var, SlaveTernTable table, Int32Var+ tuple) {
    is_slave_op = |tuple| == 3;
    method_name = native_table_method_prefix(table) & if is_slave_op then "_slave_insert" else "_insert";
    args = (table.master if is_slave_op, table_var) & tuple & (:mem_pool);
    return (native_call(method_name, args));
  }


  String* native_immediate_delete_tuple_code(TableVar table_var, AnyTable table, Maybe[Int32Var]+ tuple) {
    if not (a <- tuple : a != nothing) {
      method_action_descr = "_clear";
      args = (table_var, :mem_pool if arity(table) != 1);
    }
    else {
      method_action_descr = "_delete";
      if (a <- tuple : a == nothing) {
        col_code_suffix = match (table, tuple)
          column()                                |
          slave_column(),     (just(), nothing)   = "",
          slave_tern_table(), (just(), nothing)   = "_12",
          _,                  _                   = "_" & append((_print_(i + 1) : a @ i <- tuple, a != nothing));
        method_action_descr = method_action_descr & col_code_suffix;
      }
      args = (table_var) & (value(a) : a <- tuple, a != nothing);
      args = (args | :mem_pool) if delete_needs_mem_pool_arg(table);
    }
    method_name = native_table_method_prefix(table) & method_action_descr;
    return (native_call(method_name, args));


    Bool delete_needs_mem_pool_arg(AnySurrTable) = false;

    Bool delete_needs_mem_pool_arg(AnyColumn column) =
      match (column.repr)
        object        = true,
        int | float   = false;

  }


  String* native_immediate_update_tuple_code(TableVar table_var, <Table, MasterBinTable> table, Int32Var+ tuple, Maybe[(ValueStoreId, ValueStoreType)]+ owned_value_stores) {
    assert table.keys != [];

    arity = arity(table);
    keys = table.keys;

    method_name = native_table_method_prefix(table) & "_update";
    base_args = (table_var) & tuple & (:mem_pool);
    vs_args = value_stores_args(owned_value_stores);

    assert |vs_args| == 2 * arity;
    assert arity != 2 or (keys == [[0]] or keys == [[0], [1]]);

    if arity == 2 {
      vs_args = if keys == [[0]] then slice(vs_args, 2, 2) else vs_args;
    }
    else {
      ord_keys = (k : k <- ord_tern_table_keys, keys(k));
      assert ord_keys != ();
      suffix = append(("_" & append((_print_(i + 1) : i <- sort(k))) : k <- ord_keys));
      method_name = method_name & suffix;
      vs_args = if      keys == [[0, 1]]          then slice(vs_args, 4, 2)
                else if keys == [[0, 1], [0, 2]]  then slice(vs_args, 2, 4)
                else                                   vs_args;
    }

    return (native_call(method_name, base_args & vs_args));
  }


  String* native_immediate_update_tuple_code(TableVar table_var, SlaveTernTable table, Int32Var+ tuple, Maybe[(ValueStoreId, ValueStoreType)]+ owned_value_stores) {
    assert table.keys != [];

    is_slave_op = |tuple| == 3;

    method_action_descr = if is_slave_op then "_slave_update" else "_update";
    ord_keys = (k : k <- ord_tern_table_keys, table.keys(k));
    assert ord_keys != ();
    keys_info = append(("_" & append((_print_(i + 1) : i <- sort(k))) : k <- ord_keys));
    method_name = native_table_method_prefix(table) & method_action_descr & keys_info;

    vs_args = value_stores_args(owned_value_stores);
    assert |vs_args| == 6;
    args = (table.master if is_slave_op, table_var) & tuple & (:mem_pool) & slice(vs_args, 4, 2);

    return (native_call(method_name, args));
  }


  String* native_queue_insert_tuple_code(TableVar table_var, Table table, Int32Var+ tuple, Bool forced) {
    if forced {
      deletes_args = ((maybe(v, k(i)) : v @ i <- tuple) : k <- isort(table.keys));
      code = (native_queue_deletes_code(table_var, table, as) : as <- deletes_args);
    }
    else
      code = ();

    aux_struct = pending_updates_var_ref_name(table_var);
    arity = arity(table);
    needs_table_var_arg = arity == 1 or arity == 3 or (arity == 2 and table.keys == [[0]]);
    needs_mem_pool_arg = arity == 1 or (arity == 2 and table.keys != []);
    args = (table_var if needs_table_var_arg, aux_struct) & tuple & (:mem_pool if needs_mem_pool_arg);
    code = (code | native_call(native_table_method_prefix(table) & "_aux_insert", args));

    return code;
  }


  String* native_queue_insert_tuple_code(TableVar table_var, SlaveTernTable table, Int32Var+ tuple, Bool forced) {
    assert table.keys == [] or table.keys == [[0, 1]] or table.keys == [[0, 1], [2]];
    assert |tuple| == 2 or |tuple| == 3;

    keys = table.keys;
    method_name_prefix = native_table_method_prefix(table);
    aux_struct = pending_updates_var_ref_name(table_var);

    if |tuple| == 2 {
      if forced {
        method_name_action = "_aux_update";
        method_name_action = method_name_action & "_12" if keys([0, 1]);
        method_name_action = method_name_action & "_3" if keys([2]);
      }
      else
        method_name_action = "_aux_insert";

      args = (aux_struct) & tuple;
    }
    else {
      if forced {
        method_name_action = "_aux_slave_update";
        method_name_action = method_name_action & "_12" if keys([0, 1]);
        method_name_action = method_name_action & "_3" if keys([2]);
      }
      else
        method_name_action = "_aux_slave_insert";

      args = (aux_struct, table.master, pending_updates_var_ref_name(table.master)) & tuple;
    }

    method_name = method_name_prefix & method_name_action;
    return (native_call(method_name, args));
  }


  String native_queue_insert_master_tuple_code(Int32Var assoc_surr_var, TableVar table_var, AnySurrTable table, Int32Var+ tuple) {
    aux_struct = pending_updates_var_ref_name(table_var);
    args = (table_var, aux_struct) & tuple;
    return native_call(assoc_surr_var, native_table_method_prefix(table) & "_aux_insert", args);
  }


  String* native_init_db_code(AnyDBVar db_var, LocDBVar* links, DBSymbol db_type) {
    fail if not db_var :: LocDBVar;

    args = (db_var) & links & ("env");
    aux_args = (db_var, updater_var_ref_name(db_var)) & (updater_var_ref_name(l) : l <- links);
    return (native_call(init_method_name(db_type), args), native_call(aux_init_method_name(db_type), aux_args));

    // return (
    //   native_new_call(db_var, native_name(db_type), (links | "env")),
    //   native_method_call(
    //     updater_var_ref_name(db_var),
    //     db_var,
    //     updater_creation_proc_name(db_type),
    //     (updater_var_ref_name(d) : d <- links)
    //   ) if db_var :: LocDBVar
    // );
  }


  String* native_try_block_code(LocVar var, Instr+ body, Maybe[Nat] block_id) = (
    "try {"
  ) & indent_lines(native_code(body, block_id)) & (
    "}",
    "catch (...) {",
    "  " & native_var_ref_name(var) & " = make_null_obj();",
    "}"
  );


  // String native_set_table_code(RelVar relvar, Table table, AtomicExpr state, Nat+ perm) {
  //   perm_args = match (perm)
  //     (_)       = (),
  //     (0, 1)    = (false),
  //     (1, 0)    = (true),
  //     (_, _, _) = perm;
  //   // args = (pending_updates_var_ref_name(relvar)) & table.value_stores &
  //   //        (updater_var_ref_name(vs) : vs <- table.value_stores) & perm_args;
  //   return native_method_call(pending_updates_var_ref_name(table_var(relvar)), "set", (state) & perm_args);
  // }


  String native_queue_deletes_code(TableVar table_var, <Table, MasterBinTable, AnyColumn> table, Maybe[Int32Var]+ args) {
    set_args = (a != nothing : a <- args);
    base_names = if is_symmetric(table) then sym_fn_names_by_args else fn_names_by_args;
    prefix = match (table)
      mandatory_column()  = if set_args == (true, false)
                              then native_table_method_prefix(table)
                              else native_column_method_prefix(table.repr),
      _                   = native_table_method_prefix(table);
    method_name = prefix & "_aux_" & base_names(set_args);
    auxiliary = pending_updates_var_ref_name(table_var);
    ad_hoc_args = match (table)
      table()             = ( table_var if match (set_args)
                                (false)             |
                                (true, true)        |
                                (true, _,    _)     |
                                (_,    true, _)     |
                                (_,    _,    true)  = true,
                                (true, false)       |
                                (false, true)       = arity(table) == 2 and table.keys != [],
                                _                   = false
                            ),
      master_bin_table()  = (table_var if set_args == (true, true)),
      column()            = (table_var if set_args == (true, false)),
      slave_column()      = (table_var if set_args == (true, false)),
      mandatory_column()  = (table.master if set_args == (true, false));
    call_args = (ad_hoc_args | auxiliary) & (native_expr(value(a)) : a <- args, a != nothing);
    call_args = match (table, set_args)
      table(),  (true)  = (call_args | :mem_pool),
      _,        _       = call_args;
    return native_call(method_name, call_args);


    [Bool+ -> String] fn_names_by_args = [
      (true)                  -> "delete",
      (false)                 -> "clear",
      (true,  true)           -> "delete",
      (true,  false)          -> "delete_1",
      (false, true)           -> "delete_2",
      (false, false)          -> "clear",
      (true,  true,  true)    -> "delete",
      (true,  true,  false)   -> "delete_12",
      (true,  false, true)    -> "delete_13",
      (false, true,  true)    -> "delete_23",
      (true,  false, false)   -> "delete_1",
      (false, true,  false)   -> "delete_2",
      (false, false, true)    -> "delete_3",
      (false, false, false)   -> "clear"
    ];

    [Bool+ -> String] sym_fn_names_by_args = [
      (true,  true)           -> "delete",
      (true,  false)          -> "delete_1",
      // (false, true)           -> undefined,
      (false, false)          -> "clear",
      (true,  true,  true)    -> "delete",
      (true,  true,  false)   -> "delete_12",
      (true,  false, true)    -> "delete_13_23",
      (false, true,  true)    -> "delete_13_23",
      (true,  false, false)   -> "delete_1_2",
      (false, true,  false)   -> "delete_1_2",
      (false, false, true)    -> "delete_3",
      (false, false, false)   -> "clear"
    ];
  }


  String native_queue_deletes_code(TableVar table_var, SlaveTernTable table, Maybe[Int32Var]+ args) {
    set_args = (a != nothing : a <- args);
    base_names = if is_symmetric(table) then sym_fn_names_by_args else fn_names_by_args;
    prefix = native_table_method_prefix(table);
    method_name = prefix & "_aux_" & base_names(set_args);
    auxiliary = pending_updates_var_ref_name(table_var);
    call_args = (table_var if set_args == (true, true), auxiliary, table.master if |args| == 3) & (native_expr(value(a)) : a <- args, a != nothing);
    return native_call(method_name, call_args);

    [Bool+ -> String] fn_names_by_args = [
      (true,  true)           -> "delete",
      (true,  false)          -> "delete_12",
      (false, true)           -> "delete_3",
      (false, false)          -> "clear"
    ];

    [Bool+ -> String] sym_fn_names_by_args = [
      (true,  true)           -> "delete",
      (true,  false)          -> "delete_12",
      (false, true)           -> "delete_3",
      (false, false)          -> "clear"
    ];
  }


  String* native_send_external_msg_code(LocDBVar db_var, DBSymbol db_type, AtomicExpr msg, BoolVar res_var, Maybe[HandlerId] maybe_handler_id) {
    if maybe_handler_id == nothing {
      methods_array_name = msg_handler_entry_point_array(db_type);
      resolver_name = handler_dispatch_resolver_name(db_type);
      handler_name_or_method_pointer_lookup_expr = methods_array_name & "[" & resolver_name & "(" & native_expr(msg) & ")]";
    }
    else {
      handler_id = value(maybe_handler_id);
      msg_type = prg_data.handlers_msg_type(db_type)(handler_id);
      handler_name_or_method_pointer_lookup_expr = msg_handler_entry_point_name(db_type, handler_id, msg_type);
    }

    db_var_name = native_var_ref_name(db_var);
    aux_var_name = aux_var_decl_name(db_var);
    args = (db_var_name, aux_var_name, msg, "env");
    line = native_call(res_var, handler_name_or_method_pointer_lookup_expr, args);
    return (line);
  }


  String* native_send_internal_msg_code(LinkedDBVar db_var, DBSymbol db_type, AtomicExpr msg, Maybe[HandlerId] maybe_handler_id) {
    if maybe_handler_id == nothing {
      methods_array_name = msg_handler_array(db_type);
      resolver_name = handler_dispatch_resolver_name(db_type);
      handler_name_or_method_pointer_lookup_expr = methods_array_name & "[" & resolver_name & "(" & native_expr(msg) & ")]";
    }
    else {
      handler_id = value(maybe_handler_id);
      msg_type = prg_data.handlers_msg_type(db_type)(handler_id);
      handler_name_or_method_pointer_lookup_expr = native_handler_name(db_type, handler_id, msg_type);
    }

    db_var_name = native_var_ref_name(db_var);
    aux_var_name = pending_updates_var_ref_name(db_var);
    msg_var = dependee_msg_var_ref_name(db_var);

    args = (db_var_name, aux_var_name, msg, "env");
    call_expr = native_call_expr(handler_name_or_method_pointer_lookup_expr, args);
    return (
      "// HERE HERE HERE",
      "if (!is_blank(" & msg_var & "))",
      "  return false;",
      msg_var & " = " & native_expr(msg) & ";",
      "if (!" & call_expr & ")",
      "  return false;"
    );




    // method_name = update_name(db_type, main_handler);
    // aux_db_var_name = updater_var_ref_name(db_var);
    // msg_var_name = dependee_msg_var_ref_name(db_var);
    // return (
    //   "if (!is_blank(" & msg_var_name & "))",
    //   "  soft_fail(NULL);",
    //   msg_var_name & " = " & native_expr(msg) & ";"
    // );
  }


  String* native_set_state_code(AtomicExpr state, LocDBVar db_var, DBSymbol db_type, BoolVar res_var) {
    method_name = set_state_entry_point_name(db_type);
    args = (native_var_ref_name(db_var), updater_var_ref_name(db_var), state, "env");
    return (native_call(res_var, method_name, args));
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

implicit context : NativeContext {
  String* native_release_before_delete_code(TableVar table_var, AnySurrTable table, Maybe[Int32Var]+ args, Nat col_idx, ValueStoreId store, ValueStoreType store_type) {
    delete_cols_str = match (table, args)
      slave_tern_table(), (just(), nothing) = "12",
      _,                  _                 = append((_print_(i + 1) : a @ i <- args, a != nothing));
    method_name = native_table_method_prefix(table) & "_release_" & _print_(col_idx + 1) & "_before_delete_" & delete_cols_str;
    remove_method_name = native_value_store_method_prefix(store_type) & "_remove_untyped";
    call_args = (table_var) & values(args) & (remove_method_name, store);
    return (native_call(method_name, call_args));
  }


  String* native_value_store_release_code(ValueStoreId store, ValueStoreType store_type, Int32Var surr) {
    method_name = native_value_store_method_prefix(store_type) & "_remove";
    needs_mem_pool_arg = match (store_type)
      object                          = true,
      integer | mono_tagged_integer() = false;
    return (native_call(method_name, (store, surr, :mem_pool if needs_mem_pool_arg)));
  }


  String* native_value_store_clear_code(ValueStoreId store, ValueStoreType store_type) {
    method_name = native_value_store_method_prefix(store_type) & "_clear";
    needs_mem_pool_arg = match (store_type)
      object                          = true,
      integer | mono_tagged_integer() = false;
    return (native_call(method_name, (store, :mem_pool if needs_mem_pool_arg)));
  }


  String* native_value_store_apply_code(ValueStoreId store_id, ValueStoreType store_type) {
    method_prefix = native_value_store_method_prefix(store_type);
    apply_method_name = method_prefix & "_aux_apply_insertions";
    reset_method_name = method_prefix & "_aux_reset";
    aux_struct_id = updater_var_ref_name(store_id);
    return (
      native_call(apply_method_name, (store_id, aux_struct_id, :mem_pool)),
      native_call(reset_method_name, (aux_struct_id))
    );
  }
}
